\documentclass[finnish]{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{float}
\begin{document}
\onehalfspacing

%l‰hdeluettelo oikeaan formaattiin
\makeatletter
\renewcommand\@biblabel[1]{[#1]}
\makeatother


\title{Historiakatsaus assemblyk‰‰nt‰jist‰ korkean tason kielten k‰‰nt‰jiin}
\author{Arttu Kilpinen}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua}
\classification{\protect{\ \\
Software and its engineering -> software notations and tools -> Compilers}}

\keywords{Historia, K‰‰nt‰j‰t, Symbolinen konekieli, Ohjelmointikielet}

\begin{abstract}

  Ensimm‰iset ohjelmointikielten k‰‰nt‰j‰t, assemblyk‰‰nt‰j‰t, k‰‰nsiv‰t symbolisille
  konekielille kirjoitettuja ohjelmia konekielisiksi ohjelmiksi. T‰sm‰llisten
  kuvausj‰rjestelmien kehitys sek‰ koodin generoinnin teoria mahdollistivat
  tehokkaampien ohjelmointikielten kehityksen. Nykyisin k‰ytˆss‰ olevat
  korkean tason ohjelmointikielet kehittyiv‰t hiljalleen kuvausj‰rjestelmien
  kehittyess‰ ja syrj‰yttiv‰t symbolisella konekielill‰ ohjelmoinnin l‰hes
  kokonaan.
  T‰ss‰ dokumentissa k‰yd‰‰n l‰pi historiallisia vaiheita symbolisten konekielten
  k‰‰nt‰jist‰ nykyaikaisiin korkean tason ohjelmointikielten k‰‰nt‰jiin. L‰pi k‰yd‰‰n
  useita merkitt‰vi‰ ohjelmointikieli‰ ja niiden ominaisuuksia.
  
\end{abstract}

\mytableofcontents




\section{Johdanto}
K‰‰nt‰j‰t ovat tietokoneohjelmia, jotka k‰‰nt‰v‰t l‰hdekielisen ohjelmakoodin
kohdekieliseksi ohjelmaksi~\cite{Bauer74}. Kohdekielen‰ on usein jonkin prosessoriarkkitehtuurin
ymm‰rt‰m‰ konekieli.

%
Ohjelmointikielet sek‰ niit‰ ymm‰rt‰v‰t k‰‰nt‰j‰t ja tulkit ovat keskeisess‰ asemassa
ohjelmistotuotannossa. K‰‰nt‰j‰t mahdollistavat ohjelmien
kirjoittamisen korkean tason ohjelmointikielill‰ sek‰ symbolisilla konekielill‰,
jotka puolestaan helpottavat ja nopeuttavat ohjelmointia.
Niiden k‰ytt‰minen tekee ohjelmakoodista myˆs ymm‰rrett‰v‰mp‰‰ ja
helpompilukuista. Yleisesti ottaen ohjelmointikielen ymm‰rrett‰vyys kasvaa abstraktiotason
kasvaessa. Esimerkiksi matemaattisesti tutulla tavalla kirjoitetut aritmeettiset lausekkeet
ovat ymm‰rrett‰v‰mpi‰ kuin vastaava laskenta symbolisella konekielell‰ ohjelmoituna.
Lis‰ksi useat korkean tason ohjelmointikielet mahdollistavat --- mik‰li
tarvittavat k‰‰nt‰j‰t ovat olemassa --- saman ohjelmakoodin k‰ytt‰misen useissa eri
laitteistoissa sek‰ useilla eri k‰yttˆj‰rjestelmill‰. Koska eri laitteistoissa
on erilaiset k‰skykannat, poistuu korkean tason ohjelmointikieli‰ k‰ytt‰m‰ll‰
myˆs tarve uudelleenohjelmoinnille. 

%
% Jotain introa myˆs historiasta. Johdannon pit‰isi kuitenkin johdattaa tekstiin joka on
% p‰‰asiassa historiapainotteista. 
%

Symboliset konekielet sek‰ korkean tason ohjelmointikielet ovat l‰hes yht‰ vanhoja kuin
ohjelmointikin. Ensimm‰iset korkean tason ohjelmointikielten k‰‰nt‰j‰t puolestaan ovat
ohjelmointikieli‰ huomattavasti nuorempia, sill‰ ohjelmointikielten teoriaa kehitettiin
vuosia ennen kuin ensimm‰iset k‰‰nt‰j‰t valmistuivat. Esimerkiksi ensimm‰isen‰ korkean
tason ohjelmointikielen‰ pidetty Plankalk¸l kehitettiin jo vuonna 1946, mutta sit‰
ymm‰rt‰v‰ k‰‰nt‰j‰ valmistui vasta vuonna 1972~\cite{Knuth76}.
%

Ennen korkeatasoisille lausekielille kehitettyj‰
k‰‰nt‰ji‰ oli pitk‰‰n k‰ytˆss‰ vain symbolisia konekieli‰ ymm‰rt‰vi‰ ohjelmia, % pitk‰‰n?
assemblyk‰‰nt‰ji‰. Korkean tason ohjelmointikielten kehitytty‰ saatiin myˆs niit‰
tukevia k‰‰nt‰ji‰ valmistettua. Vuonna 1952 valmistunut AUTOCODEn k‰‰nt‰j‰ oli
yksi ensimm‰isi‰ kaupallisessa ohjelmistotuotannossa k‰ytettyj‰ korkean tason kielen
k‰‰nt‰ji‰~\cite{Knuth76}.

\newpage

%vaatii muutosta start
%Vaikka k‰‰nt‰jien tuottama kohdekieli on usein laitteiston ymm‰rt‰m‰‰ konekielt‰
%tai symbolista konekielt‰, on myˆs olemassa k‰‰nt‰ji‰, jotka tuottavat jotakin
%korkean taso lausekielt‰. 

% T‰h‰n myˆs jotain introa k‰‰nnˆstekniikoista cross, bootstrap, parsereista jne
% pit‰is saada puoltoista sivua teksti‰

%vaatii muutosta end


%T‰m‰n kirjoituksen tukena sopii k‰ytett‰v‰ksi pian laitoksen
%www-sivuilla julkaistava \LaTeX-ohje ja \LaTeX-tyyli.



%t‰‰ koko kappale on ihan vitun perseest‰ :::::D
\section{Symbolinen konekieli ja assemblyk‰‰nt‰j‰t}
%tietojenk‰sittelytieteess‰ ON OSIA jotka ei yht‰ t‰sm‰llist‰...
%Koska tietojenk‰sittelytiede ei ole yht‰ t‰sm‰llist‰ kuin matematiikka, ovat
%m‰‰ritelm‰t usein v‰hemm‰n t‰sm‰llisi‰ ja saattavat poiketa toisistaan.
Samoille asioille on tietojenk‰sittelytieteess‰ annettu hieman toisistaan poikkeavia m‰‰ritelmi‰.
Er‰‰n m‰‰ritelm‰n mukaan assemblyk‰‰nt‰j‰ on k‰‰nt‰j‰, joka k‰‰nt‰‰ yksi yhteen
symbolisella konekielell‰ kirjoitettuja komentoja konekielisiksi komennoiksi~\cite{Salomon93}.
%
Koska jokaisella laitteistolla on oma konekielens‰ ja t‰m‰ konekieli on myˆs ohjelmointikieli,
p‰tee yleinen k‰‰nt‰jien m‰‰ritelm‰ myˆs assemblyk‰‰nt‰jiin. L‰hdekielen‰ assemblyk‰‰nt‰j‰n
ymm‰rt‰m‰ symbolinen konekieli tarkoittaa konekielt‰, jossa laitteen ymm‰rt‰m‰t bin‰‰riset konek‰skyt
on korvattu ihmisille helpommin muistettavilla sanoilla eli symboleilla.
%http://www.dcs.warwick.ac.uk/~edsac/Software/EdsacTG.pdf edsac instruction set



%Aika ennen symbolisia konekieli‰. Mainitaan babbagen vehkeet
%Kerrotaan raudasta HYVIN yksinkertaisesti EDSAC z4




\subsection{Historia ensimm‰isist‰ assemblyk‰‰nt‰jist‰}
%Ensimm‰iset ohjelmointia helpottavat ohjelmat olivat assemblerk‰‰nt‰ji‰.

Koska ennen ensimm‰isi‰ assemblyk‰‰nt‰ji‰ ei ollut mit‰‰n ohjelmointia
helpottavia tyˆkaluja, tuli ensimm‰iset k‰‰nt‰j‰t ohjelmoida suoraan konekielell‰
%% Teoriassa
%% myˆs ensimm‰iset assemblyk‰‰nt‰j‰t olisi voitu toteuttaa bootstrap
%% menetelm‰ll‰, kirjoittaen osa assemblyin koodista assemblyin itsens‰
%% ymm‰rt‰m‰ll‰ kielell‰.. Vallitseva k‰yt‰ntˆ tuohon aikaan oli kuitenkin
%% toteuttaa assembly-k‰‰nt‰j‰t kokonaisuudessaan konekoodilla, kuten
%
kuten yksi ensimm‰isi‰, vuonna 1949 valmistunut EDSAC tietokoneen assemblyk‰‰nt‰j‰
toteutettiin. Vaikka korkean tason kielten k‰‰nt‰j‰t alkoivat kehitty‰
l‰hes heti ensimm‰isten assemblyk‰‰nt‰jien valmistuttua, pysyi symbolisilla
konekielill‰ ohjelmointi pitk‰‰n suosiossa. Alkuun korkean tason kielten
automaattista k‰‰nnˆstyˆt‰ pidettiin l‰hinn‰ teoreettisena tutkimisena
%VITTU EIHƒN Tƒƒ KUULU TƒHƒN KAPPALEESEEN!!!
ja k‰yt‰nnˆss‰ kaikki ohjelmoijat uskoivat ettei automaattisesta koodin generoinnista
tule ikin‰ tarpeeksi tehokasta oikeaan ohjelmointiin~\cite{Knuth76}.


Vaikka nykyaikaiset korkean tason ohjelmointikielien k‰‰nt‰j‰t tuottavat
hyvin optimoitua koodia, on hyv‰n ohjelmoijan kirjoittama symbolinen
konekieli silti l‰hes poikkeuksetta parempaa. T‰m‰n takia symbolisia %LƒHDE PYYDETTY aiempi lause
konekieli‰ k‰ytet‰‰n jonkin verran matalan tason ohjelmoinnin lis‰ksi
suurta laskentatehoa vaativien ohjelmien optimointiin.
%
Ennen symbolisten konekielten kehityst‰ ohjelmointi tapahtui kirjoittamalla
laitteistoriippuvaista tietyn prosessorin ymm‰rt‰m‰‰ bin‰‰rikoodia. Siit‰ huolimatta,
ett‰ k‰skykannat olivat nykyiseen verrattuna suhteellisen yksinkertaisia, 
oli ohjelmointi hidasta ja tyˆl‰st‰. Tietokoneiden kehittyess‰ ja ohjelmien
monimutkaistuessa tarve ohjelmointikielille kasvoi. Symboliset konekielet
kehitettiin varhain ja nykyisin l‰hes kaikki sovellusohjelmat kirjoitetaan
korkean tason ohjelmointikielill‰.
% Miss‰?
% Milloin?

\subsection{Assemblyk‰‰nt‰jien toiminnasta ja toteutuksesta}
%T‰m‰ tekee matalan tason ohjelmointikielist‰ eli (symbolisista) konekielist‰ t‰ysin laitteistoriippuvaisia.
Assemblyk‰‰nt‰j‰t ymm‰rt‰v‰t jotakin symbolista konekielt‰ ja osaavat
tuottaa t‰st‰ konekielisen suoritettavan ohjelman.
Symboliset konekielet ovat matalan tason laiteriippuvaisia ohjelmointikieli‰,
jotka k‰‰nt‰v‰t l‰hdekoodia yksinkertaisin ennalta m‰‰r‰tyin ehdoin kohdekielelle.
Suurin osa ohjelmakoodista on siis k‰‰nnett‰viss‰ yksi yhteen laitteiston
ymm‰rt‰m‰n konekielen kanssa. Poikkeuksena on kuitenkin ohjelman osoitteina
k‰ytett‰v‰t tunnukset (label), joiden arvot assemblyk‰‰nt‰j‰ voi
vapaasti p‰‰tt‰‰. Tunnuksina ovat joko paikat ohjelman koodiosassa
tai muuttujina k‰ytetyt muistipaikat. Symbolisen konekielen avainsanat
ovat siis symboleja laitteiston ymm‰rt‰m‰lle konekielelle. Konekielell‰ on
mahdollista kirjoittaa suoraan suorittimen rekistereihin. T‰m‰ tekee symbolisilla konekielill‰ ohjelmoimisesta
yht‰ laitel‰heist‰ kuin suoraan konekielill‰ ohjelmointikin. Laitel‰heisyys
puolestaan tekee ohjelmista laitteistoriippuvaisia, sill‰ eri suorittimilla
voi olla erilaiset k‰skykannat. Symbolien k‰ytt‰minen v‰hent‰‰ huomattavasti
kirjoitusvirheiden m‰‰r‰‰ ja tekee koodista helpomman kirjoittaa ja lukea.
Tunnisteiden k‰yttˆ puolestaan poistaa tarpeen muistaa muuttujien sek‰
konek‰skyjen osoitteita. 
% Miten?

%jotain direktiiveist‰
% labeleista. Ei t‰ysin yksi yhteen! KUVA! 


Kuva 1 selvent‰‰ symbolisten konekielten m‰‰tittelemien symbolien
sek‰ ohjelmoijan m‰‰rittelemien tunnisteiden eron. Esimerkkikoodi on TTK91 ~\cite{Ttk91}
virtuaaliprosessorille tehty ohjelma, joka tulostaa k‰ytt‰j‰lle luvut
0...5. Keltaisella pohjalla olevat symbolit ovat niin sanottuja tunnisteita,
joilla voi olla eri arvo k‰‰nnˆskerrasta ja k‰‰nt‰j‰st‰ riippuen.
Kaikki harmaalla pohjalla oleva koodi k‰‰nnet‰‰n siis t‰ysin ennalta m‰‰r‰tysti.


\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{esimerkkiTTK.png}
\caption{TTK91 esimerkkikoodi}
\label{kuvaesimerkki}
\end{center}
\end{figure}

\newpage
\section{Historiaa korkean tason kielten k‰‰nt‰jist‰}

Korkean tason ohjelmointikielell‰ tarkoiteteen t‰ss‰ dokumentissa ohjelmointikielt‰,
jossa l‰hdekielikieli sek‰ siit‰ k‰‰nnett‰v‰ konekieli ovat  % nyt vittu poissuljetaan ne k‰‰nt‰j‰t jotka ei k‰‰nn‰ assyks tai bin‰‰riks!
selke‰sti eri abstraktiotasoilla ja k‰‰nt‰minen edellytt‰‰ muutakin, kuin mekaanista
sanojen vaihtamista ennalta m‰‰r‰ttyjen s‰‰ntˆjen perusteella. T‰m‰n m‰‰ritelm‰n
perusteella korkean tason ohjelmointikielill‰ tarkoitetaan t‰ss‰ dokumentissa niit‰ kieli‰,
jotka eiv‰t ole symbolisia konekieli‰.

% Kerrotaan korkean tason kielten hyˆdyist‰ ja miksi niit‰ tarvitsee
\subsection{T‰sm‰llisten kuvausj‰rjestelmien kehitys}

Tietojenk‰sittelytieteilij‰t ovat jo tietokoneiden alkuajoista l‰htien
yritt‰neet kuvailla ohjelmien suoritusta ja algoritmeja konekielt‰
abstraktimmalla tasolla. Alan Turingin julkaisussa vuonna 1936 esitettiin
m‰‰ritelm‰ tietojenk‰sittelijˆiden hyvin tuntemasta laskentalaitteesta,
Turingin koneesta. Laitteen yhteydess‰ m‰‰riteltiin
% HMM? eikˆ laite itse ole jo m‰‰ritelm‰ esitystavasta?
myˆs matemaattinen esitystapa, jolla sen toimintaa voitiin t‰sm‰llisesti %LƒHTEET turing oma!
kuvailla. Vaikka esitystapa oli vaikea eik‰ kyseisi‰ Turingin
esittelem‰‰ laitetta ollut kuin teoreettisella teoriassa,
Turingin esitystapa edusti kehittyneint‰ formaalia
kuvausta, 'kielt‰', joka siihen aikaan oli olemassa. %millon tuli lambda?

Toisen maailmansodan j‰lkeen vuonna 1945 saksalainen Konrad Zuse aloitti %LƒHTEET PYYDETTY mul on paperilla!
oman tietokoneohjelmien kuvailuun tarkoitetun kielen Plankalk¸lin kehitt‰misen.
Zusen sanoin Plankalk¸lin tarkoitus oli luoda puhtaasti formaali esitystapa
mille tahansa laskentaongelmalle ~\cite{Knuth76}. T‰ss‰ h‰n onnistuikin varsin hyvin.
Plankalk¸lissa voidaan m‰‰ritell‰ aritmetiikan ja ohjausrakenteiden lis‰ksi
rajaton m‰‰r‰ sis‰kk‰isi‰ tietorakenteita ja Zusen tyˆhˆn viitataankin
usein ensimm‰isen‰ korkean tason ohjelmointikielen‰.
%
Vaikka kyseess‰ oli huomattavan edistyksellinen j‰rjestelm‰, se ei
kuitenkaan vaikuttanut ohjelmointikielten kehitykseen juuri lainkaan.
Zusen artikkelit julkaistiin vasta vuonna 1972 muiden, kehittyneempien
kielten jo olemassa ollessa. Vaikka Plankalk¸lille toteutettiinkin
k‰‰nt‰j‰, ei sit‰ juuri koskaan k‰ytetty koska silloin oli jo Plankalk¸lia
huomattavasti kehittyneempi‰ ohjelmointikieli‰.

%% -''thus  the plankalkul arose purely as a piece of desk-work..''
%% -45 alkoi plankalkulin kehitys. extension of Hilbert's Aussagenkalkul (propositional calculus) and pr‰dikatenkalkul
%% (propositional calculus)
%% -zusen k‰suikirjoitus julkaistiin asta 1972,
%% -k-‰sikirjoitus alkaa 'The mission of the plancalculus is to provide a purely formal description of any
%% computational procedure' -> Ajatuksena ei varsinaisesti ollut kieli vaan notaatio ohjelmille, Ei suunnitellut k‰‰nt‰j‰‰.
%% -plankalkul included the important concept of hierarchically structured data going all the way dowen to the bit level. suck
%% advanced data structures did not enter again int o programming languages until the late 1950 in imbss commercial translator.
%% %zu45    - zuse marked that the number of possible data types was so large ti would be impiossible to indicate a variables
%% % type simply by using typographical conventions


Samoihin aikoihin Zusen kanssa Yhdysvaltalaiset Herman Goldstine ja
John von Neumann koittivat ratkaista samaa ongelmaa. Heid‰n ratkaisunsa
algoritmien ja tietokoneohjelmien kuvaamiseen oli varsin erilainen.
Von Neumann ja Goldstine esittiv‰t ratkaisuksi lohkokaaviota (flow diagram),
esitystapaa jossa ohjelmat kuvataan nuolien ja laatikoiden avulla. %LƒHTEEEEEEET

% VAATII HIOMISTA START

%CU50', CU48, CU50 %VITTU KOKO Tƒƒ CURRY ON WIKLAN MIELEST PASKAA PISTETƒƒ UUSIKS
Vuonna 1946 Marylandissa tyˆskennellyt Haskell B. Curry kehitti ENIAC
tietokoneelle aikaansa n‰hden monimutkaista ohjelmaa. Curryn tyˆ ENIACIN
parissa sai h‰net ehdottamaan formalismia ohjelmistojen toiminnalle.
H‰nen formalisminsa perustui uuteen ajatukseen ohjelman suorituksen
lohkomaisesta rakenteesta, mit‰ h‰n nimitti divisiooniksi. %CU50
Divisioonien tulisi olla rakennettu niin ett‰ niiden laskenta olisi
toisistaan riippumatonta. T‰m‰n voisikin rinnastaa esimerkiksi
C-kielen paikallisiin tietorakenteisiin ja k‰‰nnˆsyksikˆihin perustuvaan
suoritukseen. Curryn formalismi oli kuitenkin hieman luonnoton %knuth74
sill‰ suoritusyksikˆill‰ oli useita lopetuskohtia sek‰ nykykielist‰ poiketen
useita aloituskohtia.
%
Historiallisesti tyˆ oli kuitenkin merkitt‰v‰, sill‰ se sis‰lsi algoritmeja
joilla kuvauksesta pystyttiin tuottamaan konekoodia. N‰it‰ rekursiivisia
--- vaikkakin toteuttamatta j‰‰neit‰ --- algoritmeja voidaankin pit‰‰ ensimm‰isin‰
koodin generointiin tarkoitettuina algoritmeina.

%% -haskel curryn monimutkaienn tyˆ eniacin kanssa sai h‰net esitt‰m‰‰n notation for program construction that is more
%% compact than flowcharts.
%% -actually the main feature of interest in currys earlier work is not this programming language but rather the algorithms
%% hediscussed for converting parts of it into machine language. he gave a recursive description of a procedure to convert
%% faifly general arithmetic
%% expression into code for a one address compuiter thereby being the first person to describe the code generation phase of a compiler.
%% syntaksin tarkastusta ei kuitenkaan ollut vaan k‰‰nt‰j‰? oletti sen olevan ok.
% END





\subsection{Kohti ensimm‰isi‰ k‰‰nt‰ji‰}

Millek‰‰n aiemmin mainituista ohjelmointikielist‰ ei t‰h‰n menness‰ oltu
toteutettu k‰‰nt‰ji‰. Ne toimivat ohjelmoijien k‰sitteellisen‰ apuna auttaen
ohjelmien suunnittelussa, mutta j‰tt‰en toteutuksen ihmisille. T‰st‰ huolimatta
ne kaikki olivat merkitt‰vi‰ askeleita kohti parempia ohjelmointikieli‰ sek‰
niiden k‰‰nt‰ji‰. Ilman t‰sm‰llisi‰ esitystapoja ei koodin generointi ikin‰
olisi tullut mahdolliseksi.



% MAUCHLY 
Ensimm‰inen korkean tason ohjelmointikieli, jolle toteutettiin tulkki oli Short Code.
Sit‰ kehitti John W. Mauchly vuonna 1949 ja William F. Schmitt toteutti sille tulkin ~\cite{Knuth76}.
Tulkki toimi alkuun BINAC tietokoneella mutta se ohjelmoitiin myˆhemmin myˆs UNIVACille.
Yksityiskohtia Short Coden toiminnasta ei ikin‰ julkaistu, joten sen tarkemmasta
toiminnasta ei ole tietoa. Vuonna 1955 julkaistusta ohjelmoijille tarkoitetussa
manuaalissa kerrotaan kuitenkin kuinka ohjelmaa voidaan k‰ytt‰‰. % RR55
Short Code oli siis algebrallinen tulkki, joka osasi suorittaa aritmeettisia %mik‰ vittu on algebrallinen tulkki t. wikla
laskutoimituksia ilman konekielist‰ ohjelmointia. Ohjelma luki syˆtett‰ ja
suoritti vastaavat toiminnot ajetulla laitteistolla.

% RUTISHAUER & B÷HM


1950-luvun alussa Heiniz Rutishauser ja Corrado Bˆhm tyˆskenteliv‰t Z¸richin
teknillisess‰ yliopistossa Sveitsiss‰. Vaikka he tyˆskenteliv‰t samassa paikassa
ja saman aiheen parissa, eiv‰t he tyˆskennelleet yhdess‰. Rutishauser julkaisi
1952 artikkelin, jossa h‰n kuvasi hypoteettisen tietokoneen sek‰ siin‰ toimivan
k‰‰nt‰j‰n kehitt‰m‰lleen ohjelmointikielelle. Julkaisu oli merkitt‰v‰, sill‰
siin‰ kuvattiin ensimm‰ist‰ kertaa menetelm‰ k‰‰nt‰jien toteuttamisesta %LƒHTEET t. wikla
sek‰ koodin generoinnista. % mit‰ eroa curryn algoritmeihin n‰hden?? RU52


Rutishauserin kollega Corrado Bˆhm kehitti myˆs ohjelmointikielt‰ sek‰
t‰m‰n k‰‰nt‰j‰‰. H‰nen julkaisunsa oli Rutishauserin julkaisua viel‰kin
merkitt‰v‰mpi, sill‰ h‰n oli toteuttanut k‰‰nt‰j‰n t‰m‰n omalla kielell‰.
Bˆhmin kieli ei kuitenkaan osannut k‰sitell‰ muita kuin positiivisia
kokonaislukuja, joten sen k‰yttˆarvo j‰i melko pieneksi. K‰‰nt‰jien
teorian kehityksen kannalta se oli kuitenkin korvaamaton. Bˆhmin k‰‰nt‰j‰ %LƒHTEET
kykeni tarkistamaan koodin syntaksia lineaarisessa ajassa kun Rutishauserin
k‰‰nt‰j‰ toimi suuruusluokassa $n≤$. Lis‰ksi Bˆhmin k‰‰nt‰j‰ hallitsi matemaattisten
operaattoreiden sidontaj‰rjestyksen, sek‰ osasi k‰sitell‰ sulkeita aritmeettisissa %LƒHTEET
lausekkeissa. Lis‰ksi Bˆhm oli ensimm‰inen tietojenk‰sittelij‰, joka todisti % oliko ensimm‰inen vai ensimm‰inen t‰ss‰ dokumentissa?
matemaattisesti ohjelmointikielens‰ voivan laskea mink‰ tahansa laskettavan funktion. %BO52 universaali. parempi sana??
%rutishauser and bˆhm had had a considerable advantage over glennie in that they had designed theri own machine code


% VITTU MITƒ PASKAA START
Vaikka Rutishauser ja Bˆhm olivat kumpikin valmistaneet %vittu oliko??
omat k‰‰nt‰j‰ns‰, pidet‰‰n ensimm‰isen‰ 'oikeana' k‰‰nt‰j‰n‰ silti
Alick E. Glennien 1952 valmistamaa AUTOCODE ohjelmistoa. Aiemmista k‰‰nt‰jist‰ poiketen
AUTOCODE toteutettiin oikealle laitteistolla ja sen tuottama konekieli
oli oikeasti suoritettavissa. AUTOCODEa pystyttiin siis k‰ytt‰m‰‰n oikeiden,
k‰yttˆkelpoisten ohjelmien tekemiseen ~\cite{Knuth76}.

%% --- vaikka olikin kokeneille ohjelmoijille tarkoitettu ~\cite[Knuth74]
%% --- k‰ytettiin, kuten tarkoitus oli, oikeaan ohjelmointiin.

%VITTU MITƒ PASKAA END

%Murray k‰ytti ensimm‰isen‰ sanaa compiler

% EHKƒ NƒMƒ VIELƒ OMIKSI LUVUIKSEEN

%maininta IBM!
Vuoden 1954 alussa John Backus rupesi kehitt‰m‰‰n kokoamansa kehitt‰j‰tiimin kanssa
automaattisen ohjelmoinnin j‰rjestelm‰‰. J‰rjestelm‰n oli tarkoitus olla hyvin
kehittynyt, joten suureksi haasteeksi muodostui j‰rjestelm‰n saaminen tarpeeksi
tehokkaaksi. Loppuvuodesta 1954 kehitt‰j‰ryhm‰ julkaisi suunnitelman j‰rjestelm‰st‰ 'The IBM 
Mathematical FORmula TRANstating system' --- FORTRAN. Kuten jo aiemmin oli todettu, %LƒHTEET t. wikla
tehokkaan koodin tuottaminen ei ollut lainkaan helppoa. Ryhm‰n julkaisu alkoikin
painottamalla sit‰ tosiasiaa, ett‰ FORTRAN oli tehokas. Aiemmin ohjelmoijien tuli
valita helpon ohjelmoinnin ja hitaan suorituksen tai tyˆl‰‰n ohjelmoinnin ja nopean
suorituksen v‰lilt‰, mutta FORTRANin tarjoaisi parhaat puolet molemmista ~\cite{IBM54}. %IB54 EN OO VIEL LUKENU MUT MENK÷÷
FORTRAN 0 dokumentti esitt‰‰ myˆs ensimm‰isen yrityksen esitt‰‰ ohjelmointikielen
syntaksi t‰sm‰llisesti. T‰t‰ voidaan pit‰‰ Backuksen myˆhemmin esittelem‰n kielioppimuodon
Backus Naur Formin (BNF) edelt‰j‰n‰.
%ei oltu viel‰ implementoitu. Tyˆhen meni 2.5 vuotta!!!

Kun FORTRAN kaksi ja puoli vuotta myˆhemmin saatiin toteutettua, oli se
aikansa tehokkain sek‰ monipuolisin ohjelmointikieli. FORTRAN tuotti
kohtuullisen tehokasta koodia ja kehitt‰j‰t sanoivat sen olevan l‰hes
yht‰ tehokasta kuin hyv‰n ohjelmoijan kirjoittama symbolinen konekieli.
FORTRANissa oli myˆs paljon ominaisuuksia, joita ei oltu aiemmin n‰hty.
Se oli esimerkiksi ensimm‰inen ohjelmointikieli, jossa muuttujien nimet
voivat olla useamman merkin pituisia ~\cite{Knuth76}. %ent‰ ass kielten tunnukset t. wikla

Ensimm‰isen julkaisun j‰lkeen FORTRANissa oli kuitenkin useita ognelmia.
Virheit‰ oli paljon ja er‰s FORTRANIN kehitt‰jist‰, Saul Rosen, %OLIKO SAUL ROSEN kehitt‰j‰!?
%OLIKO bugeja edes paljon vai viitattiinko tossa aikaan ennen julkaisua perkele?!
sanoikin ettei uskonut FORTRANin ikin‰ tulevan toimimaan~\cite{Rosen64}.
Vaikeuksista huolimatta FORTRANista tuli hyvin suosittu ja sit‰ k‰ytetiin
enemm‰n kuin oltiin osattu odottaa.



%% Almost to a ma nthey firmly believed that any mechanical coding method would fail to apply that versatile ...
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -57
%% -paljon tuntemattomia projekteja sill‰ olivat niin edistyksellisi‰ ettei tutkimustuloksia ikin‰ julkaistu.

%% -Alick glennie AUTOCODE 1952
%% -yleisesti pidet‰‰n ensimm‰isen‰ ``oikeana'' ``kunnon'' k‰‰nt‰j‰n‰.-
%% - glennie sanoin 1953: to  make it easy one must make coding  comprehensible. this may be done only by improving the
%% notation of programming., aikaisemmat notaatiot ovat ongelmallisia.
%% ‰- autocode was still very machine oriented.
%% - autocode oli t‰rke‰ askel eteenp‰in  vaikka olikin machine oriented ja tarkoitettu kokeneille ohjelmoijille

%% TƒHƒN MENNESSƒ kukaan ei ollut k‰ytt‰nyt viel‰ termi‰ k‰‰nt‰j‰. termin‰ oli automaattinen koodausw (automatic coding)
%% sitten sit‰ k‰ytettiin


%% -1954 John Backus tyˆskenteli ibm tehd‰kseen paremman systeemin automaattisesta ohjelmoinnista BA 76
%% -suuri ongelma oli tehokkuus. L‰hes kaikki alalla uskoivat ett‰ any mechanical coding method would fail apply that
%% versatile ingenuity which each programmer felt he possessed and vonstantly neededi nhis gwork.
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -by november 1954 bakusin ryhm‰ oli speksannu the ibm mathematical formula translating system FORTRAN.

%% ensimm‰inen paragrafi IB 54 t‰hdensi ett‰ aiemmat systeemit olivat tarjonneet vaihtoehdoiksi helpon ohjelmoinnin ja
%% hitaan suorituksen tai tyˆl‰‰n ohjelmoinnin ja nopean suorituksen. mutta fortranilla molemmat olivat mahdollisia.

%% fortran oli enswimm‰inen kieli miss‰ muuttujalla voi olla useamman merkin nimi.

%% -fortran 0 dokumentti esitteli ensimm‰isen yrityksen m‰‰ritell‰ ohjelmointikielen syntaksi t‰sm‰llisesti. bakusin t‰rke‰ huomio
%% BA 95 mist‰ tuli BNF voidaan n‰hd‰ tulevan t‰‰lt‰.



%% -assemblyien suosio pysyi esim koska esim x k‰‰nt‰j‰n optimointi oli paska. vain 50% tehokas

% ensimm‰inen k‰‰nt‰j‰ vasta 1975 Joachim Hohmann: Der Plankalk¸l im Vergleich mit algorithmischen Sprachen. Reihe Informatik und Operations Research, S. Toeche-Mittler Verlag, Darmstadt 1979, ISBN 3-87820-028-5161.
% ensimm‰inen 'useful' 'real' compiler, knuth 77 - sivu 42.
%% \section{tekniikkaa}
%% \subsection{bootstrapping}
%% \subsection{cross compiling}














\section{k‰‰nt‰jien toteutus korkealla abstraktiotasolla}

However one could discuss how an existing compiler could propagate an image of itself to another machine.
This technique popularly referred to as bootstrapping or cross compiling ~\cite{Reynolds03}.

An interesting problem is finding the simplest subset of the language that enables us to create the next generation of the compiler ~\cite{Reynolds03}.



if a compiler for language L is implemented in L, then it should be able to
compile itself.

A conventional C compiler, written in C, is said to be bootstrapped if it compiles itself.
Now suppose a new version of the compiler source is weirren, that uses different registers for passing arguments.
The old compiler can compile this source, yelding a new compiler. But Look! The executable version cc'
of the new compiler uses the old parameter passing style, but generates code that uses the new style.
onecan use the new compiler however to recompile all the libraries and the new version itself
and get a new new executable thet both uses and generates the new parameter passing style ~\cite{Appel94}.

-Cross compilation has become popular viimeist‰‰n 76.
-Tarkoittaa sorsan k‰‰nt‰mist‰ masiinalla joka outputtaa toisen masiinan objektikoodia.
-intermediate language as a tool to reduce duplivaton of effort.
-aika- ja rautarajotuksista johtuen korkean tason kielten k‰yttˆ on increasingly popular minicomputers on usein ep‰k‰yt‰nnˆllist‰
-t‰m‰n takia cross compilation saanut paljon huomiota.
-cc on prosessi of one machine accepting a source program as input and producing an object code thet is executable on another machine.
-ongelma k‰‰nt‰jien m‰‰rien kanssa, siksi IL.
-Saanut alkunsa UNCOLsta
-YMS
~\cite{Speetjens76}.

Tekniikkaa voidaan k‰ytt‰‰ usealla tavalla, useaan eri ongelmaan ~\cite{Earley70}. full, incremental ja cross!

%Bootstrapping menetelm‰‰ k‰ytet‰‰n usein myˆs ristiink‰‰nt‰misess‰ (cross compiling)
%joten kyseinen luku k‰sittelee osittain myˆs sit‰.


\subsection{T-kaaviot}

K‰‰nt‰jien suunnittelussa ja mallintamisessa on k‰ytetty useita erilaisia kaavioita.
K‰ytetyin ja tunnetuin lienee Harvey Bratmanin 1961 ehdottama
k‰‰nt‰j‰‰ kuvaava kaavio ~\cite{Bratman61}, %cit needed for k‰ytetyin och tunnetuin
josta k‰y ilmi k‰‰nt‰j‰n ymm‰rt‰m‰ kohde- ja l‰hdekieli sek‰ kieli, jolla k‰‰nt‰j‰ toimii.
Kaaviota kutsutaan Bratman-kaavioksi tai T-kaavioksi. J‰lkimm‰inen nimi tulee kaavion
muodosta, jossa T-kirjaimen muotoisessa alueessa vasen p‰‰ty kertoo l‰hdekielen, oikea
p‰‰ty kohdekielen ja alaosa kertoo mill‰ kielell‰ k‰‰nt‰j‰ toimii.

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{basic-T.png}
\caption{T-kaavio, joka kuvaa x86 arkkitehtuurilla toimivaa c-k‰‰nt‰j‰‰, jonka kohdekieli on x86 konekieli}
\label{kuvaesimerkki}
\end{center}
\end{figure}

Kaavioita toisiinsa liitt‰m‰ll‰ voidaan havainnollistaa monimutkaisiakin toimintaketjuja,
joita k‰‰nt‰j‰t suorittavat. Kuvassa 3 oletetaan ett‰ k‰ytˆss‰ on c-kielell‰ kirjoitettu
k‰‰nt‰j‰, joka k‰‰nt‰‰ ada-kielt‰ x86 konekielelle. Lis‰ksi k‰ytˆss‰ on edellisen kuvan esimerkiss‰
oleva x86 arkkitehtuurilla toimiva c-k‰‰nt‰j‰, jonka kohdekieli on x86 konekieli.
N‰iden kahden k‰‰nt‰j‰n avulla voidaan tuottaa x86 alustalla toimiva ada k‰‰nt‰j‰,
jonka kohdekieli on x86. Kahden ensimm‰isen k‰‰nt‰j‰n yhteistyˆll‰ saadaan siis kolmas
k‰‰nt‰j‰. Huomattavaa on, ett‰ prosessin alimman tasoinen k‰‰nt‰j‰ toimii aina jossakin todellisessa
laitteistossa, eik‰ t‰ten voi olla muu kuin jonkin laitteiston ymm‰rt‰m‰ konekieli.

%T‰h‰n v‰liin j‰‰ vittumaisesti tyhj‰‰ tilaa

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{multi-T.png}
\caption{c:ll‰ kirjoitetun ada-k‰‰nt‰j‰n ja x86:lla toimivan c k‰‰nt‰j‰n avulla voidaan tuottaa x86:lla toimiva ada-k‰‰nt‰j‰}
\label{kuvaesimerkki}
\end{center}
\end{figure}

T-kaavio oli melko yksinkertainen, joten siit‰ on kehitetty paranneltuja vaihtoehtoja.
Jay Earley ja Howard Sturgis laajensivat Bratmanin kaaviota lis‰‰m‰ll‰ siihen ominaisuuksia.
Alkuper‰isen T-kaavion kuvatessa vain k‰‰nt‰ji‰, Earleyn ja Sturgisin kaavioissa pystyi
kuvaamaan myˆs tulkkeja. Lis‰ksi kaavioon sis‰llytettiin suoritusta kuvaava osa
sek‰ sovellusohjelmaa kuvaava kaavio. Heid‰n kaavioissaan m‰‰ritell‰‰n kuvan 4
mukaiset elementit.

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=1.0]{notations-T.png}
\caption{Earleyn ja Sturgisin versio T-kaavioista}
\label{kuvaesimerkki}
\end{center}
\end{figure}

Vasemmalta oikealle k‰ytyn‰ ensimm‰inen kuva on Bratmanin alkuper‰isen T-kaavion vastaava elementti.
Se kuvaa k‰‰nt‰j‰‰ joka k‰‰nt‰‰ kielelt‰ A kielelle B ja toimii kielell‰ C. Suorakaiteen muotoinen
kahdesta elementist‰ koostuva kaavio kuvaa tulkkia, joka tulkkaa kielt‰ C ja toimii kielell‰ D.
Jotta k‰‰nnˆs voitaisiin suorittaa, tulee pohjimmaisen kielen olla suoritettavissa jollakin oikealla
laitteistolla. T‰t‰ suoritusta kuvaamaan lis‰ttiin yksiosainen kolmiomerkint‰. Kolmion sis‰ll‰
oleva merkint‰ kertoo mit‰ konekielt‰ suoritus ymm‰rt‰‰, esimerkkikuvassa konekieli on D ~\cite{Mogensen10}.
Esitett‰ess‰ jotakin laskentaongelmaa, joka on ohjelmoitu kielell‰ D merkit‰‰n lampun muotoinen kaavio,
jonka sis‰ll‰ kyseinen kieli ilmoitetaan.
Kyseisi‰ kaavioita voi yhdistell‰ hyvinkin monimutkaisiksi rakenteiksi. Esimerkkikuvan viimeinen kohta kuvaa
yksitt‰ist‰ k‰‰nnˆst‰, jossa A-kielinen ohjelma k‰‰nnet‰‰n B kieliseksi ohjelmaksi.
Huomioitava T-kaavioiden k‰ytˆss‰ on, ett‰ kielten vierekk‰isten kaavioiden kielten tulee t‰sm‰t‰
toisiinsa. Kuvan esimerkin k‰‰nnˆs ei voi ottaa l‰hdeohjelmakseen muuta kuin kielell‰ A kirjoitetun ohjelman.

%T‰h‰n lukuun tulee osittain myˆs cross compiling juttuja. Cross compilingiss‰ kerrotaan enemm‰n IL pohjaisesti
\subsection{bootstrapping}
%t‰h‰n menness‰ l‰htein‰ l‰hinn‰ Mogensen ja Appel
Koska k‰‰nt‰jien ohjelmointi matalan tason ohjelmointikielill‰ on eritt‰in vaivalloista,
suositaan niiden kehitt‰misess‰ korkean tason ohjelmointikielten k‰yttˆ‰  ~\cite{Mogensen10}.
Yksi vaihtoehto on kirjoittaa laitteistolle k‰‰nt‰j‰, jollakin kyseiselle laitteistolle
jo olemassa olevalla ohjelmointikielell‰. T‰m‰ ei kuitenkaan aina ole mahdollista.
Esimerkiksi jos kyseess‰ on uusi prosessoriarkkitehtuuri, eik‰ t‰lle viel‰ ole k‰‰nt‰ji‰,
joudutaan ohjelmointi tekem‰‰n jollakin muulla tavalla.
Haluttaessa k‰‰nt‰j‰n joka sek‰ k‰‰nt‰‰ ett‰ suorittuu kyseisell‰ arkkitehtuurilla er‰s
yleisesti k‰ytetty menetelm‰ on bootstrapping ~\cite{Mogensen10}. %IBID! Pit‰isikˆ suomentaa?

Bootstrapping on tekniikka jonka ydinajatus on k‰‰nt‰‰ jokin k‰‰nt‰j‰ sill‰ itsell‰‰n ~\cite{Mogensen10}
ja tavanomaisen k‰‰nt‰j‰n sanotaan olevan bootstr‰p‰tty %suomennos?
jos se k‰‰nt‰‰ itsens‰ ~\cite{Appel94}.

%incremental bootstrap
%aloita kuvaamalla tilanne jossa ei ole k‰‰nt‰ji‰?
Perinteinen ongelma k‰‰nt‰jien kehityksess‰ on tilanne, jossa k‰‰nt‰j‰ pit‰‰ rakentaa
ilman tai l‰hes ilman muita tyˆkaluja ja k‰‰n‰ji‰. Iteratiivisessa bootstrap-
menetelm‰ss‰ k‰‰nt‰j‰ kehitet‰‰n kahdessa p‰‰vaiheessa. Ensin k‰‰nt‰j‰st‰ tehd‰‰n
hyvin suppea versio, joka osaa k‰‰nt‰‰ tavoitellusta ohjelmointikielest‰ vain pienen
osajoukon ~\cite{Mogensen10}. T‰m‰ ensimm‰isen vaiheen k‰‰nt‰j‰ voidaan toteuttaa
mill‰ tahansa ohjelmointikielell‰, mutta mik‰li muiden ohjelmointikielten k‰‰nt‰ji‰
ei ole saatavilla se joudutaan kehitt‰m‰‰n konekielell‰. Toisessa vaiheessa k‰‰nt‰j‰
ohjelmoidaan sen itsens‰ ymm‰rt‰m‰ll‰ kielell‰ eik‰ muita ohjelmointikieli‰ en‰‰ tarvita.
T‰llˆin jo olemassa oleva k‰‰nt‰j‰ voi k‰‰nt‰‰ seuraavan version itsest‰‰n. 
Koska kieli on t‰ss‰ vaiheessa viel‰ hyvin vajavainen, olisi valmiin ohjelmointikielen
toteuttaminen heti ensimm‰isen vaiheen j‰lkeen eritt‰in tyˆl‰st‰ tai mahdotonta. Toista vaihetta 
suoritetaan useita kertoja siten, ett‰ k‰‰nt‰j‰n tuntemaa ohjelmointikielt‰ kasvatetaan
ja siit‰ k‰‰nnet‰‰n uusi k‰‰nt‰j‰ jonka avulla kielt‰ taas kasvatetaan ja niin edelleen.
Huomioitavaa prosessissa on se, ett‰ k‰‰nt‰j‰n uusi versio on kehitett‰v‰ aina k‰ytt‰en
vanhan version tuntemaa ohjelmointikielt‰.

Kuva 5 esitt‰‰ edell‰ mainittua tilannetta. Ensimm‰isess‰ vaiheessa k‰‰nt‰j‰n ensimm‰inen
versio ohjelmoidaan konekielell‰ (ML) ja t‰m‰n j‰lkeen ohjelmointikielt‰ (PL) laajennetaan
iteratiivisesti kunnes tavoiteltu laajuus on saavutettu.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{iterative-bootstrap-from-scratch.png}
		\caption{Iteratiivinen bootstr‰pp‰ys ilman muita ohjelmointikieli‰.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}


%half bootstrap TƒMƒ KOKO KAPPALE ON VƒHƒN HEIKOSTI KIRJOITETTU.
Bootstrap menetelm‰‰ k‰ytet‰‰n usein myˆs yhdess‰ ristiink‰‰t‰misen (cross compiling) kanssa ~\cite{Reynolds03}.
T‰llˆin tavoitteena on siirt‰‰ jo olemassa oleva k‰‰nt‰j‰ toimimaan toisessa laitteistossa.
Oletetaan ett‰ laitteistolle HW1 joka ymm‰rt‰‰ konekielt‰ ML1 on toteutettu kielen PL k‰‰nt‰j‰.
Haluttaessa kielen PL k‰‰nt‰j‰ toimimaan sek‰ tuottamaan kohdekoodia ML2 laitteistolle HW2, 
voidaan kielen PL k‰‰nt‰j‰ laitteistolle HW2 ohjelmoida ristiink‰‰nt‰mist‰ ja bootstrapingi‰ k‰ytt‰en
seuraavalla tavalla: Ensin kielell‰ PL ohjelmoidaan kielen PL k‰‰nt‰j‰ laitteistolle HW2.
T‰m‰ voidaan k‰‰nt‰‰ laitteistolla HW1. Nyt kielelle PL on olemassa laitteiston HW2 k‰‰nt‰j‰,
mutta sit‰ ei viel‰ voida suorittaa kyseisess‰ laitteistossa. Nyt K‰‰nt‰j‰n uudella versiolla,
jonka kohdekieli on ML2, k‰‰nnett‰ess‰ oma l‰hdekoodinsa, saadaan k‰‰nt‰j‰, joka sek‰ toimii
ett‰ k‰‰nt‰‰ kielelle ML2.
Kuva 6 havainnollistaa tilannetta. Ensimm‰isess‰ vaiheessa jo olemassa olevalla k‰‰nt‰j‰ll‰
k‰‰nnet‰‰n uuden k‰‰nt‰j‰n l‰hdekoodi, jolloin tulokseksi saadaan ristiink‰‰nt‰j‰.
Saadulla uudella k‰‰nt‰j‰ll‰ k‰‰nnet‰‰n sen oma l‰hdekoodi, jolloin tuloksena on haluttu
HW2 laitteistolla toimiva ja sen konekielt‰ tuottava pl kielen k‰‰nt‰j‰.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{cross-bootstrap-T.png}
		\caption{K‰‰nt‰j‰n porttaus uudelle arkkitehtuurille ristiink‰‰nt‰misen ja bootstrappingin avulla.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

%esimerkikksi ibm -> control data cite reynolds
%t‰ss‰ vois jo mainita intermediate languagen ja puhua front ja backendeist‰

%ir bootstrap
Edell‰mainittu esimerkki on toimiva, mutta se edellytt‰‰ k‰‰nt‰j‰n kirjoittamisen kokonaan
alusta loppuun asti sen itsens‰ ymm‰rt‰m‰ll‰ ohjelmointikielell‰. Koska korkean tason ohjelmointikielten
k‰‰nt‰j‰t voivat olla hyvinkin monimutkaisia ja koostua suuresta m‰‰r‰st‰ l‰hdekoodia,
on t‰m‰nkaltainen prosessi varsin tyˆl‰s. Mielenkiintoista onkin se miten vastaavan
prosessin voisi toteuttaa mahdollisimman pienell‰ vaivalla. 

Viel‰ 1970-luvulla k‰‰nt‰j‰t kirjoitettiin hyvin tarkasti tietty‰ l‰hdekielt‰ ja laitteistoa varten ~\cite{Guilan02}.
1980-luvulla ruvettiin kehitt‰m‰‰n enenev‰ss‰ m‰‰rin k‰‰nt‰j‰kokonaisuuksia jotka kykenev‰t 
k‰‰nt‰m‰‰n useita eri l‰hdekieli‰. T‰llaisissa systeemeiss‰ k‰‰nt‰j‰n sis‰inen rakenne oli 
jaettu l‰hdekielest‰ riippuvaiseen etuosaan (frontend) sek‰ n‰iden jakamaan takaosaan (backend) ~\cite{Guilan02}. %ibid
T‰m‰n kaltainen rakenne v‰hensi uuden koodin kirjoittamista ja n‰inollen pienensi k‰‰nt‰jien kehityksest‰
koituvia kustannuksia. 80-luvun lopulla oli jo hyv‰ksytty ajatus siit‰, ett‰ k‰‰nt‰jien
kehitys usealle ohjelmointikielelle ja/tai laitteistolle  on tehokkaampaa sek‰ kilpailukykyisemp‰‰.

%t‰‰ nyt ei ihan oo usealle eri kielelle mutta ehk‰ usealle eri laitteistolle
Er‰s tyypillinen tapa k‰‰nt‰j‰n ohjelmoinnissa onkin jakaa sen sis‰ist‰ rakennetta sek‰
suorittaa k‰‰nnˆs useassa eri vaiheessa. Apuna k‰ytet‰‰n usein jotakin niinsanottua 
v‰likielt‰(intermediata language) ~\cite{Speetjens76}. N‰in haluttu l‰hdekieli voidaan k‰‰nt‰‰
helpommin eri laitteistoille. 
%t‰‰ ois sit usealle eri laitteistolle.
Oletettaen, ett‰ jollekin v‰likielle ja jollekin korkean tason ohjelmointikielelle on
olemassa tietyll‰ laitteistolla toimivat k‰‰nt‰j‰t,
voidaan halutun l‰hdekielen k‰‰nnˆs suorittaa kaksivaiheisesti toteuttamalla
korkean tason ohjelmointikielell‰ k‰‰nt‰j‰ l‰hdekielelt‰ v‰likielelle ~\cite{Earley70}.
Uuden l‰hdekielen toteutus sis‰lt‰‰ siis vain korkean tason ohjelmointikielell‰ tehdyn
k‰‰nt‰j‰n k‰ytetylle v‰likielelle, eik‰ koodin generointivaihetta tarvitse kirjoittaa uudestaan.





%half bootstrap



\subsection{ristiink‰‰nt‰minen ja v‰likielet}





















\section{Yhteenveto}

Tietojenk‰sittelytieteess‰ k‰‰nt‰j‰ tarkoittaa ohjelmaa joka k‰‰nt‰‰ l‰hdekielisen
ohjelmakoodin kohdekieliseksi ohjelmakoodiksi. Koska ennen muun kuin konekielten
kehityst‰ ohjelmointi tapahtui suoraan laitearkkitehtuurin ymm‰rt‰m‰ll‰ muodolla,
ei tarvetta k‰‰nt‰jille ollut. Koska konekoodin ohjelmointi oli varsin tyˆl‰st‰,
kehitettiin avuksi symbolisia konekieli‰, joissa tietyt bin‰‰rijonot oli korvattu
paremmin muistettavilla tekstuaalisilla symboleilla.

Korkeamman tason ohjelmointikielet kehittyiv‰t ohjelmoijien tarpeesta kuvata
ohjelmistojen toimintaa korkeammilla abstraktiotasoilla. T‰sm‰lliset
kuvausj‰rjestelm‰t kehitettiin alunperin ilman ajatusta k‰‰nt‰jist‰ taikka
automaattisesta koodin generoinnista. Vaikka kuvausj‰rjestelmien sek‰ koodia
generoivien algoritmien kehitys oli alkuun vain teoreettista tutkimista,
huomattiin potentiaali niiden tehokkaaseen k‰yttˆˆn varsin pian. T‰m‰n j‰lkeen
ohjelmointikieli‰ ruvettiin kehitt‰m‰‰n varta vasten automaattisen koodin
generoinnin takia ja ensimm‰iset oikeasti hyˆdylliset kielet sek‰ niiden
k‰‰nt‰j‰t kehitettiin. 

\begin{table}[h!]
  \centering
  \caption{Yhteenveto ohjelmointikielten ja kuvausj‰rjestelmien kehityksest‰}
  \label{tab:table1}
  \begin{tabular}{| l | l | l |}
    \hline
    Kieli & Kehitt‰j‰ & Ensimm‰inen \\ \hline
    Plankalk¸l & Zuse & Ohjelmointikieli, Hierarkkinen data \\ \hline
    Virtauskaaviot & Goldstine, Von Neumann & Hyv‰ksytty ohjelmointimetodologia \\ \hline
    Short Code & Mauchly & Toteutettu korkean tason ohjelmointikieli \\ \hline
    Formules & Bˆhm & Samalla kielell‰ kirjoitettu k‰‰nt‰j‰ \\ \hline
    AUTOCODE & Glennie & K‰yttˆkelpoinen k‰‰nt‰j‰ \\ \hline %LƒHDE? lˆytyy kurssisivulta mulle suositelluista l‰hteist‰
    FORTRAN I & Backus & I/O formaatti, kommentit, globaali optimointi \\ \hline
  \end{tabular}
\end{table}

Taulukko 1 tiivist‰‰ kappaleessa 2 esitettyjen ohjelmointikielten merkitt‰vimm‰t
piirteet. Lis‰ksi taulukossa esitet‰‰n ohjelmointikielten nimet sek‰ p‰‰tekij‰t.


\newpage
%
% Sitten alkaa l‰hdeluettelo
%


\nocite{*}
 \bibliographystyle{apalike}
\bibliography{lahteet}

\lastpage

%\appendices

%\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

%Liitteet ovat t‰ss‰ vain sis‰llysluettelon ja esitystavan mallina.
%Jokainen liite aloitetaan yleens‰ uudelta sivulta, jonka alkuun tulee
%liitteen numero ja nimi. Kunkin liitteen sivut numeroidaan erikseen.

%Liite on paitsi dokumenttia t‰ydent‰v‰ osuus myˆs itsen‰inen
%kokonaisuus. Liite ei siten voi olla pelk‰st‰‰n kuva tai ohjelmanp‰tk‰,
%vaan liitteess‰ on ilmaistava sen sis‰llˆn laatu ja tarkoitus.


\end{document}
