\documentclass[finnish]{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{float}

\usepackage[round]{natbib}
\setcitestyle{notesep={: }}

\begin{document}
\onehalfspacing
%l‰hdeluettelo oikeaan formaattiin
\makeatletter
\renewcommand\@biblabel[1]{[#1]}
\makeatother


\title{Otsikko}
\author{Arttu Kilpinen}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua}
\classification{\protect{\ \\
Software and its engineering -> software notations and tools -> Compilers}}

\keywords{Historia, K‰‰nt‰j‰t, Symbolinen konekieli, Ohjelmointikielet}

\begin{abstract}

  Ensimm‰iset ohjelmointikielten k‰‰nt‰j‰t, assemblyk‰‰nt‰j‰t, k‰‰nsiv‰t symbolisille
  konekielille kirjoitettuja ohjelmia konekielisiksi ohjelmiksi. T‰sm‰llisten
  kuvausj‰rjestelmien kehitys sek‰ koodin generoinnin teoria mahdollistivat
  tehokkaampien ohjelmointikielten kehityksen. Nykyisin k‰ytˆss‰ olevat
  korkean tason ohjelmointikielet kehittyiv‰t hiljalleen kuvausj‰rjestelmien
  kehittyess‰ ja syrj‰yttiv‰t symbolisella konekielill‰ ohjelmoinnin l‰hes
  kokonaan.
  T‰ss‰ dokumentissa k‰yd‰‰n l‰pi historiallisia vaiheita symbolisten konekielten
  k‰‰nt‰jist‰ nykyaikaisiin korkean tason ohjelmointikielten k‰‰nt‰jiin. L‰pi k‰yd‰‰n
  useita merkitt‰vi‰ ohjelmointikieli‰ ja niiden ominaisuuksia.
  
\end{abstract}

\mytableofcontents




\section{Johdanto}
Johdanto.
%% K‰‰nt‰j‰t ovat tietokoneohjelmia, jotka k‰‰nt‰v‰t l‰hdekielisen ohjelmakoodin
%% kohdekieliseksi ohjelmaksi~\citep[1]{Bauer74}. Kohdekielen‰ on usein jonkin prosessoriarkkitehtuurin
%% ymm‰rt‰m‰ konekieli.

%% %
%% Ohjelmointikielet sek‰ niit‰ ymm‰rt‰v‰t k‰‰nt‰j‰t ja tulkit ovat keskeisess‰ asemassa
%% ohjelmistotuotannossa. K‰‰nt‰j‰t mahdollistavat ohjelmien
%% kirjoittamisen korkean tason ohjelmointikielill‰ sek‰ symbolisilla konekielill‰,
%% jotka puolestaan helpottavat ja nopeuttavat ohjelmointia.
%% Niiden k‰ytt‰minen tekee ohjelmakoodista myˆs ymm‰rrett‰v‰mp‰‰ ja
%% helpompilukuista. Yleisesti ottaen ohjelmointikielen ymm‰rrett‰vyys kasvaa abstraktiotason
%% kasvaessa. Esimerkiksi matemaattisesti tutulla tavalla kirjoitetut aritmeettiset lausekkeet
%% ovat ymm‰rrett‰v‰mpi‰ kuin vastaava laskenta symbolisella konekielell‰ ohjelmoituna.
%% Lis‰ksi useat korkean tason ohjelmointikielet mahdollistavat --- mik‰li
%% tarvittavat k‰‰nt‰j‰t ovat olemassa --- saman ohjelmakoodin k‰ytt‰misen useissa eri
%% laitteistoissa sek‰ useilla eri k‰yttˆj‰rjestelmill‰. Koska eri laitteistoissa
%% on erilaiset k‰skykannat, poistuu korkean tason ohjelmointikieli‰ k‰ytt‰m‰ll‰
%% myˆs tarve uudelleenohjelmoinnille. 

%% %
%% % Jotain introa myˆs historiasta. Johdannon pit‰isi kuitenkin johdattaa tekstiin joka on
%% % p‰‰asiassa historiapainotteista. 
%% %

%% Symboliset konekielet sek‰ korkean tason ohjelmointikielet ovat l‰hes yht‰ vanhoja kuin
%% ohjelmointikin. Ensimm‰iset korkean tason ohjelmointikielten k‰‰nt‰j‰t puolestaan ovat
%% ohjelmointikieli‰ huomattavasti nuorempia, sill‰ ohjelmointikielten teoriaa kehitettiin
%% vuosia ennen kuin ensimm‰iset k‰‰nt‰j‰t valmistuivat. Esimerkiksi ensimm‰isen‰ korkean
%% tason ohjelmointikielen‰ pidetty Plankalk¸l kehitettiin jo vuonna 1945, mutta sit‰
%% ymm‰rt‰v‰ k‰‰nt‰j‰ valmistui vasta vuosikymmenien p‰‰st‰. % vuonna 1972~\cite[????]{Knuth76}. %EI L÷YDY??? 
%% %vois laittaa et "yritettiin valmistaa" tms.

%% Ennen korkeatasoisille lausekielille kehitettyj‰
%% k‰‰nt‰ji‰ oli pitk‰‰n k‰ytˆss‰ vain symbolisia konekieli‰ ymm‰rt‰vi‰ ohjelmia, % pitk‰‰n?
%% assemblyk‰‰nt‰ji‰. Korkean tason ohjelmointikielten kehitytty‰ saatiin myˆs niit‰
%% tukevia k‰‰nt‰ji‰ valmistettua. Vuonna 1952 valmistunut AUTOCODEn k‰‰nt‰j‰ oli
%% yksi ensimm‰isi‰ kaupallisessa ohjelmistotuotannossa k‰ytettyj‰ korkean tason kielen
%% k‰‰nt‰ji‰ ~\cite[42]{Knuth76}. % v‰h‰n irrallaan t‰‰ autocode t‰ss‰..

\newpage

%vaatii muutosta start
%Vaikka k‰‰nt‰jien tuottama kohdekieli on usein laitteiston ymm‰rt‰m‰‰ konekielt‰
%tai symbolista konekielt‰, on myˆs olemassa k‰‰nt‰ji‰, jotka tuottavat jotakin
%korkean taso lausekielt‰. 

% T‰h‰n myˆs jotain introa k‰‰nnˆstekniikoista cross, bootstrap, parsereista jne
% pit‰is saada puoltoista sivua teksti‰


%t‰‰ koko kappale on ihan vitun perseest‰ :::::D
\section{Symbolinen konekieli ja assemblyk‰‰nt‰j‰t}
Er‰‰n m‰‰ritelm‰n mukaan assemblyk‰‰nt‰j‰ on k‰‰nt‰j‰, joka k‰‰nt‰‰
symbolisella konekielell‰ kirjoitettuja komentoja konekielisiksi komennoiksi~\cite[1]{Salomon93}.
%
Koska jokaisella laitteistolla on oma konekielens‰ ja t‰m‰ konekieli on myˆs ohjelmointikieli,
p‰tee yleinen k‰‰nt‰jien m‰‰ritelm‰ myˆs assemblyk‰‰nt‰jiin. L‰hdekielen‰ assemblyk‰‰nt‰j‰n
ymm‰rt‰m‰ symbolinen konekieli tarkoittaa konekielt‰, jossa laitteen ymm‰rt‰m‰t bin‰‰riset konek‰skyt
on korvattu ihmisille helpommin muistettavilla sanoilla eli symboleilla.
%http://www.dcs.warwick.ac.uk/~edsac/Software/EdsacTG.pdf edsac instruction set



%Aika ennen symbolisia konekieli‰. Mainitaan babbagen vehkeet
%Kerrotaan raudasta HYVIN yksinkertaisesti EDSAC z4




\subsection{Historia ensimm‰isist‰ assemblyk‰‰nt‰jist‰}
%Ensimm‰iset ohjelmointia helpottavat ohjelmat olivat assemblerk‰‰nt‰ji‰.

Koska ennen ensimm‰isi‰ assemblyk‰‰nt‰ji‰ ei ollut mit‰‰n ohjelmointia
helpottavia tyˆkaluja, tuli ensimm‰iset k‰‰nt‰j‰t ohjelmoida suoraan konekielell‰.
Esimerkiksi yksi ensimm‰isist‰ assemblyk‰‰nt‰jist‰, vuonna 1949 valmistunut EDSAC-tietokoneen
assemblyk‰‰nt‰j‰ toteutettiin t‰ll‰ tavalla. % VIITE
kuten yksi ensimm‰isi‰, vuonna 1949 valmistunut EDSAC tietokoneen assemblyk‰‰nt‰j‰
toteutettiin. Vaikka korkean tason kielten k‰‰nt‰j‰t alkoivat kehitty‰
l‰hes heti ensimm‰isten assemblyk‰‰nt‰jien valmistuttua, pysyi symbolisilla
konekielill‰ ohjelmointi pitk‰‰n suosiossa. Alkuun korkean tason kielten
automaattista k‰‰nnˆstyˆt‰ pidettiin l‰hinn‰ teoreettisena tutkimisena
%VITTU EIHƒN Tƒƒ KUULU TƒHƒNN KAPPALEESEEN!!!
ja k‰yt‰nnˆss‰ kaikki ohjelmoijat uskoivat ettei automaattisesta koodin generoinnista
tule ikin‰ tarpeeksi tehokasta oikeaan ohjelmointiin~\cite[61]{Knuth76}.


Vaikka nykyaikaiset korkean tason ohjelmointikielien k‰‰nt‰j‰t tuottavat
hyvin optimoitua koodia, on hyv‰n ohjelmoijan kirjoittama symbolinen
konekieli silti l‰hes poikkeuksetta parempaa. T‰m‰n takia symbolisia %LƒHDE PYYDETTY aiempi lause, MUTTA TY÷LƒƒMPƒƒ
konekieli‰ k‰ytet‰‰n jonkin verran matalan tason ohjelmoinnin lis‰ksi
suurta laskentatehoa vaativien ohjelmien optimointiin.
%
Ennen symbolisten konekielten kehityst‰ ohjelmointi tapahtui kirjoittamalla
laitteistoriippuvaista tietyn prosessorin ymm‰rt‰m‰‰ bin‰‰rikoodia. Siit‰ huolimatta,
ett‰ k‰skykannat olivat nykyiseen verrattuna suhteellisen yksinkertaisia, 
oli ohjelmointi hidasta ja tyˆl‰st‰. Tietokoneiden kehittyess‰ ja ohjelmien
monimutkaistuessa tarve ohjelmointikielille kasvoi. Symboliset konekielet
kehitettiin varhain ja nykyisin l‰hes kaikki sovellusohjelmat kirjoitetaan
korkean tason ohjelmointikielill‰.
% Miss‰?
% Milloin?

\subsection{Assemblyk‰‰nt‰jien toiminnasta ja toteutuksesta}
%T‰m‰ tekee matalan tason ohjelmointikielist‰ eli (symbolisista) konekielist‰ t‰ysin laitteistoriippuvaisia.
Assemblyk‰‰nt‰j‰t ymm‰rt‰v‰t jotakin symbolista konekielt‰ ja osaavat
tuottaa t‰st‰ konekielisen suoritettavan ohjelman.
Symboliset konekielet ovat matalan tason laiteriippuvaisia ohjelmointikieli‰,
jotka k‰‰nt‰v‰t l‰hdekoodia yksinkertaisin, ennalta m‰‰r‰tyin ehdoin kohdekielelle.
Suurin osa ohjelmakoodista on siis k‰‰nnett‰viss‰ yksi yhteen laitteiston
ymm‰rt‰m‰n konekielen kanssa. Poikkeuksena on kuitenkin ohjelman osoitteina
k‰ytett‰v‰t tunnukset (label), joiden arvot assemblyk‰‰nt‰j‰ voi
vapaasti p‰‰tt‰‰. Tunnuksina ovat joko paikat ohjelman koodiosassa
tai muuttujina k‰ytetyt muistipaikat. Symbolisen konekielen avainsanat
ovat siis symboleja laitteiston ymm‰rt‰m‰lle konekielelle. Konekielell‰ on
mahdollista kirjoittaa suoraan suorittimen rekistereihin. T‰m‰ tekee symbolisilla konekielill‰ ohjelmoimisesta
yht‰ laitel‰heist‰ kuin suoraan konekielill‰ ohjelmointikin. Laitel‰heisyys
puolestaan tekee ohjelmista laitteistoriippuvaisia, sill‰ eri suorittimilla
voi olla erilaiset k‰skykannat. Symbolien k‰ytt‰minen v‰hent‰‰ huomattavasti
kirjoitusvirheiden m‰‰r‰‰ ja tekee koodista helpomman kirjoittaa ja lukea.
Tunnisteiden k‰yttˆ puolestaan poistaa tarpeen muistaa muuttujien sek‰
konek‰skyjen osoitteita.
%vois sanoa ett‰ symbolinen konekieli on siis sama asia kuin konekieli, mutta symbolein kirjoitettuna.

% Miten?

%jotain direktiiveist‰
% labeleista. Ei t‰ysin yksi yhteen! KUVA! 


Kuva ~\ref{TTKesim} selvent‰‰ symbolisten konekielten symbolien
sek‰ ohjelmoijan m‰‰rittelemien tunnisteiden eron. Esimerkkikoodi on TTK91 
virtuaaliprosessorille ~\cite[]{Ttk91} tehty ohjelma, joka tulostaa k‰ytt‰j‰lle kokonaisluvut
[0, 5]. Keltaisella pohjalla olevat symbolit ovat niin sanottuja tunnisteita,
joilla voi olla eri arvo k‰‰nnˆskerrasta ja k‰‰nt‰j‰st‰ riippuen.
Harmaalla pohjalla oleva koodi k‰‰nnet‰‰n siis t‰ysin ennalta m‰‰r‰tysti.


\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{esimerkkiTTK.png}
\caption{TTK91-esimerkkikoodi. \label{TTKesim}}
\label{kuvaesimerkki}
\end{center}
\end{figure}

\newpage
\section{Historiaa korkean tason kielten k‰‰nt‰jist‰}

Korkean tason ohjelmointikielell‰ tarkoitetaan t‰ss‰ tutkielmassa ohjelmointikielt‰,
jossa l‰hdekieli sek‰ siit‰ k‰‰nnett‰v‰ konekieli ovat 
selke‰sti eri abstraktiotasoilla. Kokean tason ohjelmointikielten k‰‰nt‰minen edellytt‰‰
siis muutakin, kuin mekaanista sanojen vaihtamista ennalta m‰‰r‰ttyjen s‰‰ntˆjen perusteella.
T‰m‰n m‰‰ritelm‰n perusteella korkean tason ohjelmointikielill‰ tarkoitetaan t‰ss‰ tutkielmassa
ohjelmointikieli‰, jotka eiv‰t ole symbolisia konekieli‰.

% Kerrotaan korkean tason kielten hyˆdyist‰ ja miksi niit‰ tarvitsee
\subsection{T‰sm‰llisten kuvausj‰rjestelmien kehitys}
Tietojenk‰sittelytieteess‰ on aina koitettu kuvailla ohjelmien suoritusta
ja algoritmeja t‰sm‰llisesti. Ennen formaaleja merkint‰tapoja ja korkean tason ohjelmointikieli‰ ainoa
t‰sm‰llinen tapa algoritmien kuvaamiseksi oli niiden kirjoittaminen konekielell‰.
Alan Turingin tunnetussa julkaisussa ~\cite{Turing36} esitettiin 
m‰‰ritelm‰ laskenta-automaatista, joka paremmin tunnetaan Turingin koneena.
Sen yhteydess‰ m‰‰riteltiin myˆs matemaattinen formalismi, jolla automaatin
toimintaa voitiin t‰sm‰llisesti kuvailla. Vaikka esitystapa oli vaikea ja esitelty
automaatti hypoteettinen,
se edusti Alonzo Churchin merkint‰tavan ~\cite{Church36} ohella kehittyneint‰ formaalia
kuvausta, 'kielt‰', joka siihen aikaan oli olemassa.

%PLANKAK‹L
Toisen maailmansodan j‰lkeen vuonna 1945 saksalainen Konrad Zuse aloitti
tietokoneohjelmien kuvailuun tarkoitetun kielen Plankalk¸lin kehitt‰misen ~\cite[8]{Knuth76}.
Zusen sanoin Plankalk¸lin tarkoitus oli luoda puhtaasti formaali esitystapa
mille tahansa laskentaongelmalle ~\cite[10]{Knuth76}.
Plankalk¸lissa voidaan m‰‰ritell‰ aritmetiikan ja ohjausrakenteiden lis‰ksi
rajaton m‰‰r‰ sis‰kk‰isi‰ tietorakenteita ja Zusen tyˆhˆn viitataankin
usein ensimm‰isen‰ korkean tason ohjelmointikielen‰.

Vaikka kyseess‰ oli huomattavan edistyksellinen j‰rjestelm‰, se ei
kuitenkaan vaikuttanut ohjelmointikielten kehitykseen juuri lainkaan,
sill‰ artikkeli julkaistiin vasta vuonna 1972. Vaikka Plankalk¸lille toteutettiinkin
k‰‰nt‰j‰, ei sit‰ juuri koskaan k‰ytetty koska, silloin oli jo Plankalk¸lia
huomattavasti kehittyneempi‰ ohjelmointikieli‰. %err? oliks sit‰ k‰‰nt‰j‰‰ nyt vai ei??

%LOHKOKAAVIO
Samoihin aikoihin Zusen kanssa myˆs Yhdysvaltalaiset Herman Goldstine ja
John von Neumann kehittiv‰t laskennallista formalismia. Heid‰n ratkaisunsa
algoritmien ja tietokoneohjelmien kuvaamiseen oli varsin erilainen.
Von Neumann ja Goldstine esittiv‰t ratkaisuksi lohkokaaviota (flow diagram),
esitystapaa jossa ohjelmat kuvataan nuolien ja laatikoiden avulla ~\cite[16]{Knuth76}.
Lohkokaaviot esitellyt artikkeli ~\cite{Goldstine47} saavutti suuren lukijakunnan
ja sill‰ oli suuri vaikutus ohjelmointikielten kehitykseen ~\cite[16]{Knuth76} .


%CURRYN PASKA
%CU50', CU48, CU50 %VITTU KOKO Tƒƒ CURRY ON WIKLAN MIELEST PASKAA PISTETƒƒ UUSIKS
Vuonna 1946 Marylandissa tyˆskennellyt Haskell B. Curry kehitti ENIAC-tietokoneelle
aikaansa n‰hden monimutkaista ohjelmaa. Curryn tyˆ ENIAC:n
parissa sai h‰net ehdottamaan formalismia ohjelmistojen toiminnalle.
H‰nen formalisminsa perustui uuteen ajatukseen ohjelman suorituksen
lohkomaisesta rakenteesta. N‰it‰ itsen‰isesti suoritettavia osia h‰n nimitti divisiooniksi ~\cite[34]{Curry50}.
Divisioonat tulisi rakentaa siten, ett‰ niiden laskenta olisi
toisistaan riippumatonta. T‰m‰n voisikin rinnastaa esimerkiksi
C-kielen paikallisiin tietorakenteisiin ja k‰‰nnˆsyksikˆihin perustuvaan
suoritukseen. Curryn formalismi oli kuitenkin hieman luonnoton,
sill‰ suoritusyksikˆill‰ oli useita lopetuskohtia sek‰ nykykielist‰ poiketen
useita aloituskohtia ~\cite[21]{Knuth76}.
Historiallisesti tyˆ oli kuitenkin merkitt‰v‰, sill‰ se sis‰lsi algoritmeja
joilla kuvauksesta pystyttiin tuottamaan konekielt‰. N‰it‰ rekursiivisia
--- vaikkakin toteuttamatta j‰‰neit‰ --- algoritmeja voidaankin pit‰‰ ensimm‰isin‰ %no oliks niit algoritmei edes??
koodin generointiin tarkoitettuina algoritmeina. % t‰‰ kohta nyt on ihan vitun ripulia

%% -actually the main feature of interest in currys earlier work is not this programming language but rather the algorithms
%% hediscussed for converting parts of it into machine language. he gave a recursive description of a procedure to convert
%% faifly general arithmetic
%% expression into code for a one address compuiter thereby being the first person to describe the code generation phase of a compiler
%% syntaksin tarkastusta ei kuitenkaan ollut vaan k‰‰nt‰j‰? oletti sen olevan ok. mik‰ vitun k‰‰nt‰j‰?


\subsection{Kohti ensimm‰isi‰ k‰‰nt‰ji‰}

Millek‰‰n aiemmin mainituista ohjelmointikielist‰ ei niiden julkaisun yhteydess‰
toteutettu k‰‰nt‰ji‰. N‰m‰ kielet toimivat ohjelmoijien k‰sitteellisen‰ apuna auttaen
ohjelmien suunnittelussa, mutta j‰tt‰en toteutuksen ihmisille. T‰st‰ huolimatta
ne olivat merkitt‰vi‰ askeleita kohti parempia ohjelmointikieli‰ sek‰
niiden k‰‰nt‰ji‰. Ilman t‰sm‰llisi‰ esitystapoja ei koodin generointi eli
varsinainen k‰‰nnˆksen tai tulkkauksen suorittaminen ikin‰ olisi voinut tulla mahdolliseksi.

% MAUCHLY 
Ensimm‰inen korkean tason ohjelmointikieli, joka toteutettiin oli Short Code .
Sit‰ kehitti John W. Mauchly vuonna 1949 ja William F. Schmitt toteutti sille tulkin ~\cite[23]{Knuth76}.
Tulkki toimi alkuun BINAC-tietokoneella mutta se ohjelmoitiin myˆhemmin myˆs UNIVAC:lle.
Yksityiskohtia Short Coden toiminnasta ei ikin‰ julkaistu, joten sen tarkemmasta
toiminnasta ei ole tietoa. Vuonna 1955 julkaistussa ohjelmoijille tarkoitetussa
manuaalissa kerrotaan kuitenkin kuinka ohjelmaa voidaan k‰ytt‰‰. % RR55 Ei lˆydy
Short Code oli siis algebrallinen tulkki, joka osasi suorittaa aritmeettisia %mik‰ vittu on algebrallinen tulkki t. wikla
laskutoimituksia ilman konekielist‰ ohjelmointia. Ohjelma luki syˆtett‰ ja
tulkkasi vastaavat toiminnot ajetulle laitteistolle.

% RUTISHAUER & B÷HM
1950-luvun alussa Heiniz Rutishauser ja Corrado Bˆhm tyˆskenteliv‰t Z¸richin
teknillisess‰ yliopistossa Sveitsiss‰. Vaikka he tyˆskenteliv‰t samassa paikassa
ja saman aiheen parissa, eiv‰t he tyˆskennelleet yhdess‰. Rutishauser julkaisi
vuonna 1952 artikkelin, jossa h‰n kuvasi hypoteettisen tietokoneen sek‰ siin‰ toimivan
k‰‰nt‰j‰n kehitt‰m‰lleen ohjelmointikielelle ~\cite[30]{Knuth76} . Julkaisu oli merkitt‰v‰, sill‰
siin‰ kuvattiin ensimm‰ist‰ kertaa menetelm‰ k‰‰nt‰jien toteuttamisesta
sek‰ koodin generoinnista (Ibid). % mit‰ eroa curryn algoritmeihin n‰hden?? RU52

Myˆs Corrando Bˆhm kehitti samaan aikaan itsen‰isest ohjelmointikielt‰ sek‰
t‰m‰n k‰‰nt‰j‰‰. H‰nen julkaisunsa oli Rutishauserin julkaisua viel‰kin
merkitt‰v‰mpi, sill‰ h‰n oli toteuttanut k‰‰nt‰j‰n omalla kielell‰n‰ ~\cite[36]{Knuth76}.
Bˆhmin kieli ei kuitenkaan osannut k‰sitell‰ muita kuin positiivisia
kokonaislukuja, joten sen k‰yttˆarvo j‰i melko pieneksi. K‰‰nt‰jien
teorian kehityksen kannalta se oli kuitenkin korvaamaton. Bˆhmin k‰‰nt‰j‰
kykeni tarkistamaan koodin syntaksia lineaarisessa ajassa kun Rutishauserin
k‰‰nt‰j‰ puolestaan toimi neliˆllisess‰ ajassa ~\cite[40]{Knuth76}. Lis‰ksi Bˆhmin k‰‰nt‰j‰ hallitsi matemaattisten
operaattoreiden sidontaj‰rjestyksen, sek‰ osasi k‰sitell‰ sulkeita aritmeettisissa 
lausekkeissa. Bˆhm oli myˆs ensimm‰inen, joka todisti 
matemaattisesti ohjelmointikielens‰ voivan laskea mink‰ tahansa laskettavan funktion ~\cite[42]{Knuth76}.
%rutishauser and bˆhm had had a considerable advantage over glennie in that they had designed theri own machine code


% VITTU MITƒ PASKAA START
Vaikka Rutishauser ja Bˆhm olivat kumpikin valmistaneet %vittu oliko??
omat k‰‰nt‰j‰ns‰, pidet‰‰n ensimm‰isen‰ oikeana k‰‰nt‰j‰n‰ silti
Alick E. Glennien 1952 valmistamaa AUTOCODE-ohjelmistoa ~\cite[42]{Knuth76}. Aiemmista k‰‰nt‰jist‰ poiketen
AUTOCODE ei toiminut hypoteettisella laitteistolla joten sen tuottama konekieli
oli t‰ten suoritettavissa. AUTOCODEa pystyttiin siis k‰ytt‰m‰‰n oikeiden,
k‰yttˆkelpoisten ohjelmien tekemiseen ~\cite[42]{Knuth76}.

%% --- vaikka olikin kokeneille ohjelmoijille tarkoitettu ~\cite[Knuth74]
%% --- k‰ytettiin, kuten tarkoitus oli, oikeaan ohjelmointiin.

%VITTU MITƒ PASKAA END

%Murray k‰ytti ensimm‰isen‰ sanaa compiler

% EHKƒ NƒMƒ VIELƒ OMIKSI LUVUIKSEEN

%FORTRAN T‰‰ koko fortran on aika perseest‰ kans..
Vuoden 1954 alussa John Backus rupesi kehitt‰m‰‰n kokoamansa kehitt‰j‰ryhm‰n kanssa
automaattisen ohjelmoinnin j‰rjestelm‰‰. J‰rjestelm‰n oli tarkoitus olla hyvin
kehittynyt, joten suureksi haasteeksi muodostui j‰rjestelm‰n saaminen tarpeeksi
tehokkaaksi. Loppuvuodesta 1954 kehitt‰j‰ryhm‰ julkaisi suunnitelman j‰rjestelm‰st‰ 'The IBM %LƒHTEET t. wikla
Mathematical FORmula TRANstating system' --- FORTRAN. 
Ryhm‰n julkaisu alkoi painottamalla sit‰ tosiasiaa, ett‰ FORTRAN oli tehokas. Aiemmin ohjelmoijien tuli
valita helpon ohjelmoinnin ja hitaan suorituksen tai tyˆl‰‰n ohjelmoinnin ja nopean
suorituksen v‰lilt‰, mutta julkaisun j‰lkeen FORTRAN tarjoaisi parhaat
puolet molemmista ~\cite[1]{IBM54}. %IB54 EN OO VIEL LUKENU MUT MENK÷÷
FORTRAN 0-dokumentissa on myˆs ensimm‰inen yritys esitt‰‰ ohjelmointikielen %mik‰ vittu on fortran 0 ;:DD
kielioppi t‰sm‰llisesti. T‰t‰ voidaan pit‰‰ Backuksen myˆhemmin esittelem‰n kielioppimuodon
Backus Naur Formin (BNF) edelt‰j‰n‰.
%ei oltu viel‰ implementoitu. Tyˆhen meni 2.5 vuotta!!!

Kun FORTRAN kaksi ja puoli vuotta myˆhemmin saatiin toteutettua, oli se
aikansa tehokkain sek‰ monipuolisin ohjelmointikieli. Se tuotti %siis fortranin k‰‰nt‰j‰t. kankeesti sanottu.
suhteellisen tehokasta koodia ja kehitt‰j‰t sanoivat sen olevan l‰hes
yht‰ tehokasta kuin hyv‰n ohjelmoijan kirjoittama symbolinen konekieli ~\cite[1]{IBM56}.
FORTRANissa oli myˆs paljon ominaisuuksia, joita ei oltu aiemmin n‰hty.
Se oli esimerkiksi ensimm‰inen ohjelmointikieli, jossa muuttujien nimet
voivat olla useamman merkin pituisia ~\cite[62]{Knuth76}. %ent‰ ass kielten tunnukset t. wikla

Ensimm‰isen julkaisun j‰lkeen FORTRANissa oli kuitenkin useita ongelmia.
Virheit‰ oli paljon ja er‰s FORTRAN:n kehitt‰jist‰, Saul Rosen, %OLIKO SAUL ROSEN kehitt‰j‰!?
%OLIKO bugeja edes paljon vai viitattiinko tossa aikaan ennen julkaisua perkele?!
sanoikin ettei uskonut FORTRAN:n ikin‰ tulevan toimimaan~\cite[4????]{Rosen64}.
Vaikeuksista huolimatta FORTRAN:sta tuli hyvin suosittu ja sit‰ k‰ytettiin
enemm‰n kuin oltiin osattu odottaa.

Taulukko 1 tiivist‰‰ aiemmissa kappaleissa esiteltyjen ohjelmointikielten merkitt‰vimm‰t
piirteet. Lis‰ksi taulukossa esitell‰‰n ohjelmointikielten nimet sek‰ p‰‰tekij‰t.

\begin{table}[h!]
  \centering
  \caption{Yhteenveto ohjelmointikielten ja kuvausj‰rjestelmien kehityksest‰}
  \label{tab:table1}
  \begin{tabular}{| l | l | l |}
    \hline
    \textbf K\textbf i\textbf e\textbf l\textbf i & \textbf K\textbf e\textbf h\textbf i\textbf t\textbf t\textbf ‰\textbf j\textbf ‰\textbf  & \textbf E\textbf n\textbf s\textbf i\textbf m\textbf m\textbf ‰\textbf i\textbf n\textbf e\textbf n \\ \hline
    Plankalk¸l & Zuse & Ohjelmointikieli, Hierarkkinen data \\ \hline
    Virtauskaaviot & Goldstine, & Hyv‰ksytty ohjelmointimetodologia \\
     & Von Neumann &  \\ \hline
    Short Code & Mauchly & Toteutettu korkean tason ohjelmointikieli \\ \hline
    Formules & Bˆhm & Samalla kielell‰ kirjoitettu k‰‰nt‰j‰ \\ \hline
    AUTOCODE & Glennie & K‰yttˆkelpoinen k‰‰nt‰j‰ \\ \hline %LƒHDE? lˆytyy kurssisivulta mulle suositelluista l‰hteist‰
    FORTRAN I & Backus & I/O formaatti, kommentit, globaali optimointi \\ \hline
  \end{tabular}
\end{table}

%% Almost to a ma nthey firmly believed that any mechanical coding method would fail to apply that versatile ...
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -57
%% -paljon tuntemattomia projekteja sill‰ olivat niin edistyksellisi‰ ettei tutkimustuloksia ikin‰ julkaistu.

%% -Alick glennie AUTOCODE 1952
%% -yleisesti pidet‰‰n ensimm‰isen‰ ``oikeana'' ``kunnon'' k‰‰nt‰j‰n‰.-
%% - glennie sanoin 1953: to  make it easy one must make coding  comprehensible. this may be done only by improving the
%% notation of programming., aikaisemmat notaatiot ovat ongelmallisia.
%% ‰- autocode was still very machine oriented.
%% - autocode oli t‰rke‰ askel eteenp‰in  vaikka olikin machine oriented ja tarkoitettu kokeneille ohjelmoijille

%% TƒHƒN MENNESSƒ kukaan ei ollut k‰ytt‰nyt viel‰ termi‰ k‰‰nt‰j‰. termin‰ oli automaattinen koodausw (automatic coding)
%% sitten sit‰ k‰ytettiin


%% -1954 John Backus tyˆskenteli ibm tehd‰kseen paremman systeemin automaattisesta ohjelmoinnista BA 76
%% -suuri ongelma oli tehokkuus. L‰hes kaikki alalla uskoivat ett‰ any mechanical coding method would fail apply that
%% versatile ingenuity which each programmer felt he possessed and vonstantly neededi nhis gwork.
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -by november 1954 bakusin ryhm‰ oli speksannu the ibm mathematical formula translating system FORTRAN.

%% ensimm‰inen paragrafi IB 54 t‰hdensi ett‰ aiemmat systeemit olivat tarjonneet vaihtoehdoiksi helpon ohjelmoinnin ja
%% hitaan suorituksen tai tyˆl‰‰n ohjelmoinnin ja nopean suorituksen. mutta fortranilla molemmat olivat mahdollisia.

%% fortran oli enswimm‰inen kieli miss‰ muuttujalla voi olla useamman merkin nimi.

%% -fortran 0 dokumentti esitteli ensimm‰isen yrityksen m‰‰ritell‰ ohjelmointikielen syntaksi t‰sm‰llisesti. bakusin t‰rke‰ huomio
%% BA 95 mist‰ tuli BNF voidaan n‰hd‰ tulevan t‰‰lt‰.



%% -assemblyien suosio pysyi esim koska esim x k‰‰nt‰j‰n optimointi oli paska. vain 50% tehokas

% ensimm‰inen k‰‰nt‰j‰ vasta 1975 Joachim Hohmann: Der Plankalkul im Vergleich mit algorithmischen Sprachen. Reihe Informatik und Operations Research, S. Toeche-Mittler Verlag, Darmstadt 1979, ISBN 3-87820-028-5161.
% ensimm‰inen 'useful' 'real' compiler, knuth 77 - sivu 42.
%% \section{tekniikkaa}
%% \subsection{bootstrapping}
%% \subsection{cross compiling}
















%% However one could discuss how an existing compiler could propagate an image of itself to another machine.
%% This technique popularly referred to as bootstrapping or cross compiling ~\cite{Reynolds03}.

%% A conventional C compiler, written in C, is said to be bootstrapped if it compiles itself.
%% Now suppose a new version of the compiler source is weirren, that uses different registers for passing arguments.
%% The old compiler can compile this source, yelding a new compiler. But Look! The executable version cc'
%% of the new compiler uses the old parameter passing style, but generates code that uses the new style.
%% onecan use the new compiler however to recompile all the libraries and the new version itself
%% and get a new new executable thet both uses and generates the new parameter passing style ~\cite{Appel94}.


%% -intermediate language as a tool to reduce duplivaton of effort.
%% -t‰m‰n takia cross compilation saanut paljon huomiota.
%% -cc on prosessi of one machine accepting a source program as input and producing an object code thet is executable on another machine.
%% -ongelma k‰‰nt‰jien m‰‰rien kanssa, siksi IL.
%% -Saanut alkunsa UNCOLsta
%% ~\cite{Speetjens76}.

%BURKSILLA OLI MY÷S INTERMEDIATE LANGUAGE!
\section{V‰likielet ja ristiink‰‰nt‰minen}
Jo 1950-luvun lopulla sek‰ k‰ytett‰viss‰ olevien ohjelmointikielten ett‰ erilaisten laitteistojen
m‰‰r‰ oli kasvanut merkitt‰v‰sti. Korkean tason ohjelmointikielill‰
ohjelmoinnista oli tullut yleist‰ ja sen hyˆdyt olivat laajalti tunnettuja ~\cite[12]{Strong58}.
Uusien laitteistojen kehitys oli nopeaa ja tyypillisesti laitteistoja uusittiin
viimeist‰‰n viiden vuoden v‰lein (Ibid). Vaikka korkean tason ohjelmointikielten
k‰yttˆ v‰hensi tarvetta sovellusten uudelleenohjelmoinnille, muodostui k‰‰nt‰jien
kehitys merkitt‰v‰ksi ongelmaksi. Tehokkaan k‰‰nt‰j‰n kehitt‰miseen kuluva
aika oli samaa suuruusluokkaa laitteistojen k‰yttˆi‰n kanssa,
joten hyvien k‰‰nt‰jien valmistuttua oli laitteisto usein jo vanhentunut (Ibid).
Ongelmaa koitettiin v‰ltt‰‰ erilaisilla k‰‰nnˆstekniikoilla. Yleiseksi tavaksi
muodostui ristiink‰‰nt‰minen uusille laitteistoille.

%laitetaanko t‰h‰n v‰liotsikko vai ei?
\subsection{Ristiink‰‰nt‰minen}
%https://www.gnu.org/savannah-checkouts/gnu/automake/manual/html_node/Cross_002dCompilation.html
Tavallisesti tietokonej‰rjestelmiss‰ k‰ytett‰v‰t k‰‰nt‰j‰t tuottavat konekielt‰ samalle
laitteistolle, jossa niit‰ suoritetaan. Ristiink‰‰nt‰misell‰ (cross compiling) tarkoitetaan
sit‰, ett‰ kohdelaitteisto on jokin muu kuin k‰‰nnˆst‰ suorittava laitteisto ~\cite[]{GNU16}.
Ristiink‰‰nt‰misen mahdollistamiseksi tarvitaan siis k‰‰nt‰ji‰, jotka tuottavat konekielt‰
uudelle laitteistolle. N‰m‰ ohjelmoidaan vanhalla laitteistolla jo olemassa olevia
ohjelmointikieli‰ k‰ytt‰en. T‰ten saaduilla ristiink‰‰nt‰jill‰ pystyt‰‰n k‰‰nt‰m‰‰n
k‰‰nt‰ji‰, tai muita ohjelmia, jotka toimivat uudessa laitteistossa.

%miten toi pilkku nyt menee?
Ongelmana edell‰ mainitussa menetelm‰ss‰ on suuri sek‰ kasvava joukko l‰hde- ja
kohdekieli‰. Jo yhden uuden k‰‰nt‰j‰n toteuttaminen on varsin tyˆl‰st‰, joten uuden k‰‰nt‰j‰n
tekeminen kaikille halutuille laitteistoille vaatisi valtavasti aikaa ja resursseja.
Oletetaan, ett‰ korkean tason ohjelmointikielten m‰‰r‰ on $N$ ja laitteistojen m‰‰r‰ on $M$.
T‰llˆin tarvittavien k‰‰nt‰jien m‰‰r‰ on $N \cdot M$ ja se kasvaa neliˆllisesti kohde- ja l‰hdekielien
kasvaessa. Kuva ~\ref{nxm} esitt‰‰ tilannetta jossa on k‰‰nt‰j‰t kuudelle eri ohjelmointikielelle
viiteen eri laitteistoon. 
%loppuuko t‰‰ kappale v‰h‰n tˆnkˆsti?

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{NxM.png}
		\caption{Ristiink‰‰nt‰minen usealta l‰hdekielelt‰ usealle kohdekielelle. L‰hde: ~\cite[378]{Steel61} \label{nxm}.}
		\label{kuvaesimerkki} % t‰‰ l‰hde on p‰in helvetti‰? jr??
	\end{center}
\end{figure} 

\subsection{V‰likielet}
Mik‰li olisi olemassa sellainen ohjelmointikieli, jolle olisi toteutettu k‰‰nt‰j‰ kaikille
mahdollisille laitteistoille, voitaisiin korkean tason ohjelmointikielet k‰‰nt‰‰
mille tahansa laitteistolle t‰t‰ kielt‰ apuna k‰ytt‰en. T‰llaisella menetelm‰ll‰
tarvittavien k‰‰nt‰jien m‰‰r‰ v‰henisi huomattavasti. Uudet ohjelmointikielet saataisiin
toimimaan mill‰ tahansa laitteistolla vain yhden uuden k‰‰nt‰j‰n avulla. Uuden ohjelmointikielen
k‰‰nt‰j‰t k‰‰nt‰isiv‰t niit‰ kyseiselle v‰likielelle, josta se voitaisiin jo olemassa olevien
k‰‰nt‰jien avulla k‰‰nt‰‰ mille tahansa laitteistolle.

Idea tunnettiin alunperin nimell‰ UNCOL (UNiversal Compuiter Oriented Language) ~\cite[14]{Strong58}.
UNCOL ei ollut niink‰‰n suunniteltu ohjelmointikieli, vaan pikemminkin idea v‰likielest‰,
jonka avulla k‰‰nt‰ji‰ voisi toteuttaa pienemm‰ll‰ vaivalla. Siit‰ puhuttiin jo vuonna
1954, eik‰ konseptin alkuper‰ist‰ keksij‰‰ tunneta (Ibid).

Mik‰li jonkinlainen UNCOL --- kaikkien k‰‰nt‰jien tuntema v‰likieli --- olisi olemassa,
v‰henisi ristiink‰‰nt‰miseen tarvittavien k‰‰nt‰jien m‰‰r‰ huomattavasti. Jos
ohjelmointikielten m‰‰r‰ on $N$ ja laitteistojen m‰‰r‰ $M$, tarvittaisiin t‰llaisessa
v‰likieliratkaisussa vain $N+M$ k‰‰nt‰j‰‰ ~\cite[15]{Speetjens76}. Toisin sanoen k‰‰nt‰jien m‰‰r‰ kasvaisi
lineaarisesti ohjelmointikielten ja laitteistojen suhteen. Kuvassa \ref{n+m} esitet‰‰n
tilanne v‰likielen avulla. 

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{N+M.png}
		\caption{Ristiink‰‰nt‰minen v‰likielill‰. L‰hde: ~\cite[378]{Steel61}. \label{n+m}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure} 

UNCOL:ksi on ehdotettu useita eri v‰likieli‰, mutta yhdest‰k‰‰n ei ole tullut
niin k‰ytetty‰, ett‰ sit‰ voitaisiin sanoa universaaliksi. Er‰s UNCOL:ksi ehdotettu
kieli oli Melvin Conwayn 1958 julkaisema v‰likieli. Conwayn julkaisussa
\emph{Proposal for an UNCOL}
m‰‰ritell‰‰n matalan tason v‰likieli, jota h‰n kutsuu SML:ksi (Simple Machine Language) ~\cite[5]{Conway58}.
%miks vitus toho ei tuu v‰lii

%mitetit‰‰s n‰it‰ kahta viimest‰ paragrafia viel‰. j‰lkˆll‰ oli pointtia. 
Kaikilla laitteilla toimivan v‰likielen tulisi olla t‰ysin laitteistoriippumaton. 
Laitteistoriippumattomalla kielell‰ tarkoitetaan, ett‰ se voidaan k‰‰nt‰‰ tehokkaasti
mille tahansa laitteistolle ~\cite[1060]{Brown72}. Koska erilaisia laitteistoja
on hyvin suuri m‰‰r‰, ei mik‰‰n kieli ole t‰ysin laitteistoriippumaton (Ibid).
N‰in ollen kaikille laitteistoille k‰‰nnett‰v‰n v‰likielen toteutus on
melko utopistista. Useat laitteistot ovat kuitenkin tarpeeksi samankaltaisia
tehokkaan v‰likielen kehitt‰miseksi, mik‰li tavoiteltujen kohdelaitteistojen
m‰‰r‰‰ pienennet‰‰n. Suurin osa eniten k‰ytetyist‰ tietokoneista toimii
niin samankaltaisesti, ett‰ hyv‰ v‰likieli kykenee kattamaan niist‰ suurimman osan (Ibid).


%t‰h‰n v‰liin ett‰ speetjens ehdotti UMCOLia.

Vaikka v‰likielet ovat usein laitteistol‰heisi‰ ja ne k‰‰nnet‰‰n suoraan jollekin
konekielelle, voisi v‰likieli teoriassa olla hyvinkin korkeatasoinen. Jos jollekin
laitteistolle on olemassa hyv‰ jonkin korkean tason ohjelmointikielen k‰‰nt‰j‰,
voisi v‰likieli olla myˆs korkean tason ohjelmointikieli, jonka kohdekielen‰
ei olisi mik‰‰n konekieli vaan kyseinen toinen korkean tason ohjelmointikieli ~\cite[1060]{Brown72}.
Koska t‰llainen tekniikka tuottaa k‰yt‰nnˆss‰ aina huonotasoista koodia,
k‰‰nnet‰‰n v‰likielet l‰hes poikkeuksetta, vaikka olisivatkin korkean tasoisia
ohjelmointikieli‰, suoraan konekieliksi (Ibid).



%% ...
%% Vaikka mist‰‰n ei tullut universaalia, vaikutti idea kuitenkin v‰likieltenb kehitykseen..
%% t‰h‰n ehk‰ jotain noita vitun erilaisia v‰likieli‰? vai tulisko sitteki kappaleen alkuun?


%% %ei lˆydy hyv‰‰ l‰hdett‰? ent‰: http://www.pcmag.com/encyclopedia/term/45156/intermediate-language
%% %V‰likielill‰ tarkoitetaan ohjelmointikieli‰, joka on kehitetty toimimaan v‰livaiheena
%% %k‰‰nnˆsprosessissa korkean tason ohjelmointikielilt‰ konekielille. V‰likielten avulla

%% -abstract machine modeling ei ihan sama asia koska voi olla korkean tason v‰likieli‰.
%% -voi olla matalan tai korkean tason tai jotain v‰lilt‰.
%% -tunnettu pitk‰n aikaa -54 ainakin.
%% - since introduction of uncol large number of il have been proposed
%% - ovat usein kehitetty for system development eik‰ cross compiling ne kaikki perustuu abstract machine modeling konseptiin
%% - erilaisia: machine oriented, problem oriented, hierarcicalk, combinational

%Bootstrapping menetelm‰‰ k‰ytet‰‰n usein myˆs ristiink‰‰nt‰misess‰ (cross compiling)
%joten kyseinen luku k‰sittelee osittain myˆs sit‰.
\section{T-kaaviot}

K‰‰nt‰jien suunnittelussa ja mallintamisessa on k‰ytetty useita erilaisia merkint‰tapoja.
K‰ytetyin ja tunnetuin lienee Harvey Bratmanin 1961 ehdottama T-kaavio. 
H‰n kehitti sen ~\cite[]{Strong58}-julkaisussa eisteltyn UNCOL-kaavion korvaajaksi ~\cite[]{Bratman61}. 
%pit‰‰ viel‰ kehitt‰‰. mutta totta ettei voi vaan sanoa uncol kaavio ja olla viittaamatta mihink‰‰n.

\subsection{Alkuper‰inen Bratman-kaavio}
Harvey Bratmanin esittelem‰ kaavio kuvaa yksitt‰ist‰ k‰‰nt‰j‰‰. 
Siit‰ k‰y ilmi k‰‰nt‰j‰n ymm‰rt‰m‰ kohde- ja l‰hdekieli sek‰ kieli, jolla k‰‰nt‰j‰ toimii.
Kaaviota kutsutaan Bratman-kaavioksi tai T-kaavioksi. J‰lkimm‰inen nimi tulee kaavion
muodosta, jossa T-kirjaimen muotoisessa alueessa vasempaan p‰‰tyyn merkit‰‰n l‰hdekieli,
oikeaan p‰‰tyyn kohdekieli ja alaosaan kieli jolla k‰‰nt‰j‰ toimii.

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{basic-T.png}
\caption{T-kaavio, joka kuvaa x86-arkkitehtuurilla toimivaa C-k‰‰nt‰j‰‰, jonka kohdekieli on x86-konekieli. \label{basic-t}}
\label{kuvaesimerkki}
\end{center}
\end{figure}

Kaavioita toisiinsa liitt‰m‰ll‰ voidaan havainnollistaa monimutkaisiakin k‰‰nt‰jill‰
suoritettavia toimintaketjuja. Kuvassa \ref{multi-t} oletetaan, ett‰ k‰ytˆss‰ on C-kielinen
k‰‰nt‰j‰, joka k‰‰nt‰‰ Ada-kielt‰ x86-konekielelle. Lis‰ksi k‰ytˆss‰ on kuvan \ref{basic-t} 
x86-arkkitehtuurilla toimiva C-k‰‰nt‰j‰, jonka kohdekieli on x86-konekieli.
N‰iden kahden k‰‰nt‰j‰n avulla voidaan tuottaa x86-alustalla suoritettava Ada k‰‰nt‰j‰,
jonka kohdekieli on x86. Kahden ensimm‰isen k‰‰nt‰j‰n yhteistyˆll‰ saadaan siis kolmas
k‰‰nt‰j‰. Huomattavaa on, ett‰ kaavion alin k‰‰nt‰j‰ toimii aina jossakin todellisessa laitteistossa,
eik‰ t‰ten voi olla muu kuin laitteiston ymm‰rt‰m‰ konekieli.

%T‰h‰n v‰liin j‰‰ vittumaisesti tyhj‰‰ tilaa

\begin{figure}[H]
  \ \newline
  \begin{center}
    \includegraphics[scale=0.5]{multi-T.png}
    \caption{C-kielisen Ada-k‰‰nt‰j‰n ja x86:lla toimivan C k‰‰nt‰j‰n avulla voidaan tuottaa x86:lla toimiva ada-k‰‰nt‰j‰ \label{multi-t}}
    \label{kuvaesimerkki}
  \end{center}
\end{figure}

\subsection{Earleyn ja Sturginsin merkint‰tapa}
T-kaavio on melko yksinkertainen, joten siit‰ on kehitetty paranneltuja vaihtoehtoja.
Jay Earley ja Howard Sturgis laajensivat Bratmanin kaaviota lis‰‰m‰ll‰ siihen ominaisuuksia ~\cite[607-616]{Earley70}.
Alkuper‰isen T-kaavion kuvatessa vain k‰‰nt‰ji‰, Earleyn ja Sturgisin kaavioissa pystyy
kuvaamaan myˆs tulkkeja. Lis‰ksi kaavioon sis‰llytettiin suoritusta kuvaava osa
sek‰ sovellusohjelmaa kuvaava kaavio. Heid‰n kaavioissaan m‰‰ritell‰‰n kuvan \ref{t-laajennos}
mukaiset elementit.

\begin{figure}[H]
  \ \newline
  \begin{center}
    \includegraphics[scale=1.0]{notations-T.png}
    \caption{Earleyn ja Sturgisin T-kaavioelementit. Kuvan l‰hde ~\cite[282]{Mogensen10}. \label{t-laajennos}}
    \label{kuvaesimerkki}
  \end{center}
\end{figure}

Kuvan vasemman puoleisin elementti vastaa Earleyn ja Sturgisin merkint‰tavassa alkuper‰ist‰ T-kaaviota.
Se kuvaa C-kielist‰ k‰‰nt‰j‰‰ joka k‰‰nt‰‰ kielelt‰ A kielelle B. Suorakaiteen muotoinen
kahdesta osasta koostuva kaavio kuvaa tulkkia, joka tulkkaa kielt‰ C ja toimii kielell‰ D.
Jotta k‰‰nnˆs voitaisiin suorittaa, tulee pohjimmaisen kielen olla suoritettavissa jollakin oikealla
laitteistolla. T‰t‰ suoritusta kuvaa yksiosainen kolmiomerkint‰. Kolmion sis‰ll‰
lukee mill‰ konekielell‰ suoritus tapahtuu. Esimerkkikuvassa konekieli on D.
Viimeinen kaavio tarkoittaa jotain sovellusohjelmaa tai m‰‰rittelem‰tˆnt‰ laskentaa.
Kaavion sis‰ll‰ lukee ohjelmointikieli, jolla sovellus on ohjelmoitu tai jolle se on k‰‰nnetty.
Esimerkkikuvassa kieli on D ~\cite[282]{Mogensen10}.

Kyseisi‰ kaavioita voi yhdistell‰ hyvinkin monimutkaisiksi rakenteiksi. Kuvan \ref{yhdistelma-t} esimerkiss‰ on
kaavio, joka kuvaa C++-kielisen ohjelman k‰‰nt‰mist‰ x86-konekielelle. Suoritus tapahtuu
x86-laitteistolla ja k‰‰nnˆksen tekee Pythonilla toimiva k‰‰nt‰j‰, joka tulkataan x86-laitteistossa.
Huomioitava T-kaavioiden k‰ytˆss‰ on, ett‰ kaavioiden vierekk‰isten osien kielten tulee t‰sm‰t‰
toisiinsa. Kuvan esimerkin k‰‰nnˆs ei voi ottaa l‰hdeohjelmakseen muuta kuin C++:ll‰ kirjoitetun ohjelman.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{example-Earley-T.png}
		\caption{Esimerkki Earleyn ja Sturgisin kaavioiden yhdistelemisest‰. \label{yhdistelma-t}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}


%T‰h‰n lukuun tulee osittain myˆs cross compiling juttuja. Cross compilingiss‰ kerrotaan enemm‰n IL pohjaisesti
\section{K‰‰nt‰jien rakenne ja ketjutus}
%t‰h‰n menness‰ l‰htein‰ l‰hinn‰ Mogensen ja Appel
Koska k‰‰nt‰jien ohjelmointi matalan tason ohjelmointikielill‰ on eritt‰in vaivalloista ~\cite[281]{Mogensen10},
suositaan niiden kehitt‰misess‰ korkean tason ohjelmointikielten k‰yttˆ‰.
Yksi vaihtoehto on ohjelmoida laitteistolle k‰‰nt‰j‰ jollakin kyseiselle laitteistolle
jo olemassa olevalla ohjelmointikielell‰. T‰m‰ ei kuitenkaan aina ole mahdollista.
Esimerkiksi, jos kyseess‰ on uusi prosessoriarkkitehtuuri, eik‰ t‰lle viel‰ ole k‰‰nt‰ji‰,
on ohjelmointi teht‰v‰ jollakin muulla tavalla.
K‰‰nt‰j‰, joka sek‰ k‰‰nt‰‰ ett‰ on suoritettavissa uudella laitteistolla voidaan
toteuttaa ketjutukseksi (bootstrapping) kutsutulla tekniikalla ~\cite[281]{Mogensen10}.

Ketjutus on tekniikka, jonka ydinajatus on k‰‰nt‰‰ jokin k‰‰nt‰j‰ sill‰ itsell‰‰n ~\cite[281]{Mogensen10}.
Tavanomaisen k‰‰nt‰j‰n sanotaan olevan ketjutettu jos se k‰‰nt‰‰ itsens‰ ~\cite[]{Appel94}.

\subsection{Iteratiivinen ketjutus}
%incremental bootstrap
Perinteinen ongelma k‰‰nt‰jien kehityksess‰ on tilanne, jossa k‰‰nt‰j‰ pit‰‰ ohjelmoida
ilman muita tyˆkaluja ja k‰‰nt‰ji‰. Iteratiivisessa ketjutusmenetelm‰ss‰
k‰‰nt‰j‰ kehitet‰‰n kahdessa osassa. Ensin k‰‰nt‰j‰st‰ tehd‰‰n
hyvin suppea versio, joka osaa k‰‰nt‰‰ tavoitellusta ohjelmointikielest‰ vain pienen
osajoukon ~\cite[287]{Mogensen10}. T‰m‰ ensimm‰isen vaiheen k‰‰nt‰j‰ voidaan ohjelmoida
mill‰ tahansa ohjelmointikielell‰, mutta mik‰li muiden ohjelmointikielten k‰‰nt‰ji‰
ei ole saatavilla, se joudutaan tekem‰‰n konekielell‰. Toisessa osassa k‰‰nt‰j‰
ohjelmoidaan sen itsens‰ ymm‰rt‰m‰ll‰ kielell‰, eik‰ muita ohjelmointikieli‰ en‰‰ tarvita.
T‰llˆin jo olemassa oleva k‰‰nt‰j‰ voi k‰‰nt‰‰ seuraavan version itsest‰‰n. 
Koska kieli on t‰ss‰ vaiheessa viel‰ hyvin vajavainen, olisi valmiin ohjelmointikielen
toteuttaminen heti ensimm‰isen vaiheen j‰lkeen eritt‰in tyˆl‰st‰. Toista vaihetta 
suoritetaan useita kertoja siten, ett‰ k‰‰nt‰j‰n tuntemaa ohjelmointikielt‰ kasvatetaan
ja siit‰ k‰‰nnet‰‰n uusi k‰‰nt‰j‰. Saadun k‰‰nt‰j‰n avulla voidaan seuraava versio
toteuttaa k‰ytt‰en uusia ominaisuuksia. Seuraavan version avulla tehd‰‰n j‰lleen
seuraava versio ja niin edelleen.
Huomioitavaa prosessissa on se, ett‰ k‰‰nt‰j‰n uusi versio on kehitett‰v‰ aina k‰ytt‰en 
vanhan version tuntemaa ohjelmointikielt‰. 

Kuva \ref{iterative-bootstrap} esitt‰‰ edell‰ mainittua tilannetta. Ensimm‰isess‰ vaiheessa k‰‰nt‰j‰n ensimm‰inen
versio ohjelmoidaan konekielell‰ (ML, "Machine Language") ja t‰m‰n j‰lkeen ohjelmointikielt‰ (PL, "Programming Language") laajennetaan iteratiivisesti, kunnes tavoiteltu kieli on saavutettu.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{iterative-bootstrap-from-scratch.png}
		\caption{Iteratiivinen bootstr‰pp‰ys ilman muita ohjelmointikieli‰. \label{iterative-bootstrap}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

Er‰s ongelma edell‰ kuvatussa prosessissa on kielen kehitykseen soveltuvan
sopivan osajoukon m‰‰ritteleminen ~\cite[176]{Reynolds03}. Mik‰li ohjelmointikielt‰ laajennetaan vain
v‰h‰n, on p‰ivitys l‰hes hyˆdytˆn. Liian monimutkaisen kielen toteuttaminen
yksinkertaisella osajoukolla on puolestaan eritt‰in tyˆl‰st‰.

\subsection{Ketjutus olemassa olevien k‰‰nt‰jien avulla}
%half bootstrap TƒMƒ KOKO KAPPALE ON VƒHƒN HEIKOSTI KIRJOITETTU.
Ketjutusmenetelm‰‰ k‰ytet‰‰n usein myˆs yhdess‰ ristiink‰‰nt‰misen kanssa ~\cite[175]{Reynolds03}.
T‰llˆin tavoitteena on siirt‰‰ jo olemassa oleva k‰‰nt‰j‰ toimimaan toisessa laitteistossa.
Oletetaan, ett‰ laitteistolle joka suorittaa konekielt‰ ML1 on toteutettu kielen PL k‰‰nt‰j‰.
Mik‰li kielen PL k‰‰nt‰j‰ halutaan toimimaan sek‰ tuottamaan uuden laitteiston konekielt‰ ML2, 
voidaan kielen PL k‰‰nt‰j‰ ohjelmoida uudelle laitteistolle ristiink‰‰nt‰mist‰ ja ketjuttamista k‰ytt‰en
seuraavalla tavalla. Ensin kielell‰ PL ohjelmoidaan sen itsens‰ k‰‰nt‰j‰ uudelle laitteistolle.
T‰m‰ voidaan k‰‰nt‰‰ alkuper‰isell‰ laitteistolla. Nyt kielelle PL on olemassa uudelle laitteistolle
koodia tuottava k‰‰nt‰j‰, mutta sen suoritus tapahtuu edelleen vanhassa laitteistossa (ristiink‰‰nt‰minen).
Nyt K‰‰nt‰j‰n uudella versiolla, jonka kohdekieli on ML2, k‰‰nnett‰ess‰ oma l‰hdekoodinsa,
saadaan k‰‰nt‰j‰, joka sek‰ toimii ett‰ k‰‰nt‰‰ kielelle ML2.
Kuva \ref{cross-bootstrapping} havainnollistaa tilannetta. Ensimm‰isess‰ vaiheessa jo olemassa olevalla k‰‰nt‰j‰ll‰
k‰‰nnet‰‰n uuden k‰‰nt‰j‰n l‰hdekoodi, jolloin tulokseksi saadaan ristiink‰‰nt‰j‰.
Saadulla uudella k‰‰nt‰j‰ll‰ k‰‰nnet‰‰n sen oma l‰hdekoodi, jolloin tuloksena on haluttu
uudella laitteistolla toimiva ja sen konekielt‰ tuottava PL kielen k‰‰nt‰j‰.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{cross-bootstrap-T.png}
		\caption{K‰‰nt‰j‰n siirt‰minen uudelle laitteistolle ristiink‰‰nt‰misen ja ketjutuksen avulla. \label{cross-bootstrapping}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

%esimerkikksi ibm -> control data cite reynolds
%t‰ss‰ vois jo mainita intermediate languagen ja puhua front ja backendeist‰

%ir bootstrap
Edell‰mainittu esimerkki on toimiva, mutta se edellytt‰‰ k‰‰nt‰j‰n kirjoittamisen kokonaan
alusta loppuun asti sen omalla l‰hdekielell‰. Koska korkean tason ohjelmointikielten
k‰‰nt‰j‰t voivat olla todella monimutkaisia ja koostua suuresta m‰‰r‰st‰ l‰hdekoodia,
on t‰m‰nkaltainen prosessi varsin tyˆl‰s. Vastaavan prosessin voi toteuttaa huomattavasti
pienemm‰ll‰ vaivalla, mik‰li alkuper‰isen k‰‰nt‰j‰n rakenne olisi eri tavalla toteutettu.

%ibid
\subsection{Ketjuttamista helpottava k‰‰nt‰j‰rakenne}
Viel‰ 1970-luvulla k‰‰nt‰j‰t kirjoitettiin suurimmaksi osaksi yht‰ l‰hdekielt‰ ja laitteistoa varten ~\cite[38]{Guilan02}.
1980-luvulla ruvettiin kehitt‰m‰‰n enenev‰ss‰ m‰‰rin k‰‰nt‰j‰kokonaisuuksia, jotka kykenev‰t 
k‰‰nt‰m‰‰n useita eri l‰hdekieli‰ (Ibid). T‰llaisissa systeemeiss‰ k‰‰nt‰j‰n sis‰inen rakenne oli 
jaettu l‰hdekielest‰ riippuvaiseen etuosaan (frontend) sek‰ n‰iden jakamaan takaosaan (backend).
T‰m‰n kaltainen rakenne v‰hensi tarvetta kirjoittaa uutta koodia ja n‰in ollen pienensi k‰‰nt‰jien kehityksest‰
koituvia kustannuksia. 80-luvun lopulla oli jo hyv‰ksytty ajatus siit‰, ett‰ k‰‰nt‰jien
kehitys usealle ohjelmointikielelle ja/tai laitteistolle  on tehokkaampaa sek‰ kilpailukykyisemp‰‰ (Ibid).

%t‰‰ nyt ei ihan oo usealle eri kielelle mutta ehk‰ usealle eri laitteistolle
Er‰s tyypillinen tapa k‰‰nt‰jien ohjelmoinnissa onkin jakaa sen sis‰ist‰ rakennetta sek‰
suorittaa k‰‰nnˆs useassa eri vaiheessa. Apuna k‰ytet‰‰n usein jotakin
v‰likielt‰ ~\cite[15]{Speetjens76}. N‰in haluttu l‰hdekieli voidaan k‰‰nt‰‰
helpommin eri laitteistoille.

%t‰‰ ois sit usealle eri laitteistolle.
Olettaen, ett‰ jollekin v‰likielelle IL ("Intermediate Language") ja jollekin korkean tason ohjelmointikielelle on
olemassa tietyll‰ laitteistolla toimivat k‰‰nt‰j‰t,
voidaan halutun l‰hdekielen k‰‰nnˆs suorittaa kaksivaiheisesti toteuttamalla
korkean tason ohjelmointikielell‰ k‰‰nt‰j‰ l‰hdekielelt‰ v‰likielelle ~\cite[610]{Earley70}.
Uuden l‰hdekielen toteutus sis‰lt‰‰ siis vain korkean tason ohjelmointikielell‰ tehdyn
k‰‰nt‰j‰n k‰ytetylle v‰likielelle, eik‰ koodin generointivaihetta tarvitse kirjoittaa uudestaan.

%antaako t‰‰ kappalevaihdos nyt ymm‰rt‰‰ ett‰ kuva 7 olisi ylemm‰n tilanteen kaltainen?
Kuva \ref{compiler-complex} demonstroi usein k‰ytetty‰ rakennetta ~\cite[610]{Earley70}, jolla k‰‰nt‰j‰n jatkokehityst‰ voidaan
helpottaa huomattavasti. 

Uuden ohjelmointikielen k‰‰nt‰j‰n toteuttaminen kyseisen k‰‰nt‰j‰n avulla on mahdollista
vain yhden komponentin (punainen) uudelleenohjelmoinnilla. Vaihtamalla toisen vaiheen 
ensimm‰inen k‰‰nt‰j‰ k‰‰nt‰m‰‰n uudelta l‰hdekielelt‰ (SL, "Source Language") v‰likielelle,
vaihtuu myˆs seuraavissa komponenteissa olevat l‰hdekielet uuteen kieleen.
Uusi k‰‰nt‰j‰ tulee toteuttaa samalla ohjelmointikielell‰, jolla aiempi komponentti on
toteutettu (CWL, "Compiler Writing Language").
Esimerkiksi jos kyseisell‰ j‰rjestelm‰ll‰ halutaan toteuttaa
konekielell‰ ML1 suoritettava C-k‰‰nt‰j‰, tulee ohjelmoida vain sellainen
osa, joka on kirjoitettu kielell‰ CWL ja k‰‰nt‰‰ C-kielt‰ v‰likielelle IL. Sama p‰tee
muihinkin toteutettaviin ohjelmointikieliin.

\begin{figure}[H]
	\ \newline
	\begin{center}
	    \hbox{\hspace{-0.6cm} \includegraphics[scale=1.0]{compiler-complex-color-T.png}}
	  \caption{K‰‰nt‰j‰kokonaisuus. \label{compiler-compÂlex}}
	  \label{kuvaesimerkki}
	\end{center}
\end{figure}

Pelkk‰‰ v‰likielt‰ apuna k‰ytt‰en uuden ohjelmointikielen toteutus ei vaatisi n‰in
monimutkaista rakennetta. Kyseinen rakenne mahdollistaa kuitenkin sek‰ tehokkaan ristiink‰‰nt‰misen,
ett‰ itsens‰ ketjuttamisen uudelle laitteistolle. Jos k‰‰nt‰j‰kokonaisuuden halutaan
k‰‰nt‰v‰n ymm‰rt‰m‰‰ns‰ l‰hdekielt‰ uudelle laitteistolle jonka konekieli on ML2, joudutaan siihen
edelleen kirjoittamaan vain yksi uusi komponentti. T‰m‰ osa kirjoitetaan kielell‰ CWL ja
se k‰‰nt‰‰ v‰likielt‰ IL uuden laitteiston ymm‰rt‰m‰lle konekielelle ML2.  Kun kyseinen
osa k‰‰nnet‰‰n jo olemassa olevalla k‰‰nt‰j‰ll‰, saadaan tulokseksi
samassa laitteistossa toimiva k‰‰nt‰j‰ v‰likielelt‰ uudelle konekielelle.
Saadulla ristiink‰‰nt‰j‰ll‰ on siis mahdollista k‰‰nt‰‰ l‰hdekielt‰ SL
konekielelle ML2, mutta sen suoritus tapahtuu edelleen kielen alkuper‰ist‰
konekielt‰ ML1 ymm‰rt‰v‰ss‰ laitteistossa.

Ristiink‰‰nt‰misen mahdollistavan uuden osan avulla myˆs koko k‰‰nt‰j‰rakenteen
ketjuttaminen uuteen laitteistoon on mahdollista ilman lis‰ohjelmointia ~\cite[610]{Earley70}.
Kuva \ref{bootstrap-complex} havainnollistaa t‰t‰ prosessia.
Ensimm‰isess‰ vaiheessa jo olemassaolevien
komponenttien sek‰ uuden CWL:ll‰ kirjoitetun v‰likielik‰‰nt‰j‰n (keltainen) avulla
tuotetaan seuraavissa vaiheissa tarvittavat komponentit.

N‰iden komponenttien avulla voidaan
toisessa vaiheessa tuottaa ML2-konekielell‰ toimiva ja siihen k‰‰nt‰v‰ v‰likielik‰‰nt‰j‰.
Kolmannessa vaiheessa tuotetaan ensimm‰isess‰ vaiheessa saadun v‰likielik‰‰nt‰j‰n
avulla ML2-kielell‰ toimiva CWL-k‰‰nt‰j‰, joka tuottaa v‰likielt‰.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{CWL-IL-bootstrap-complex-color-T.png}
		\caption{K‰‰n‰t‰kokonaisuuden ketjutus uudelle laitteistolle. \label{bootstrap-complex}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

Sijoittamalla toisessa ja kolmannessa vaiheessa saadut k‰‰nt‰j‰t (sininen) alkuper‰iseen %ei ihan! pit‰‰ viel‰ saada CWL,ML2,ML2
ohjelmistoon, saadaan sek‰ ML2-kielell‰ toimivat, ett‰ sille k‰‰nt‰v‰t
komponentit. Ainoa komponentti jota ei saada suoraan sijoittamalla on ensimm‰isen vaiheen toinen komponentti.
Uudella konekielell‰ toimivat k‰‰nt‰j‰t CWL $ \rightarrow $ IL ja IL $ \rightarrow $ ML2 
vastaavat kuitenkin yhdess‰ t‰t‰ komponenttia.

K‰sitelty k‰‰nt‰j‰kokonaisuus on monimutkainen, mutta myˆs tehokas. Sek‰ uuden
l‰hdekielen toteutus alkuper‰isell‰ laitteistolla ett‰ koko k‰‰nt‰j‰ohjelmiston
siirt‰minen uuteen laitteistoon voidaan saavuttaa
vain pienen osan uudelleenohjelmoinnilla. Lis‰ksi uudelleenohjelmointi
voidaan suorittaa jo aiemmin k‰ytetyll‰ korkean tason ohjelmointikielell‰ ~\cite[610]{Earley70}.

%jos t‰‰ monimutkanen esimerkki tulis cross compiling ja v‰likielie setin loppuun niin t‰st‰ olis
%luontevaa jatkaa puhumaan front ja backendist‰ ja vaikka gcc rakenteesta. 

%half bootstrap


\newpage
\section{Yhteenveto}
Yhteenveto.
%% K‰‰nt‰j‰ll‰ tarkoitetaan ohjelmaa, joka k‰‰nt‰‰ l‰hdekielisen ohjelmakoodin
%% kohdekieliseksi ohjelmakoodiksi. 


%% Tietojenk‰sittelytieteess‰ k‰‰nt‰j‰ tarkoittaa ohjelmaa joka k‰‰nt‰‰ l‰hdekielisen
%% ohjelmakoodin kohdekieliseksi ohjelmakoodiksi. Koska ennen muun kuin konekielten
%% kehityst‰ ohjelmointi tapahtui suoraan laitearkkitehtuurin ymm‰rt‰m‰ll‰ muodolla,
%% ei tarvetta k‰‰nt‰jille ollut. Koska konekoodin ohjelmointi oli varsin tyˆl‰st‰,
%% kehitettiin avuksi symbolisia konekieli‰, joissa tietyt bin‰‰rijonot oli korvattu
%% paremmin muistettavilla tekstuaalisilla symboleilla.

%% Korkeamman tason ohjelmointikielet kehittyiv‰t ohjelmoijien tarpeesta kuvata
%% ohjelmistojen toimintaa korkeammilla abstraktiotasoilla. T‰sm‰lliset
%% kuvausj‰rjestelm‰t kehitettiin alunperin ilman ajatusta k‰‰nt‰jist‰ taikka
%% automaattisesta koodin generoinnista. Vaikka kuvausj‰rjestelmien sek‰ koodia
%% generoivien algoritmien kehitys oli alkuun vain teoreettista tutkimista,
%% huomattiin potentiaali niiden tehokkaaseen k‰yttˆˆn varsin pian. T‰m‰n j‰lkeen
%% ohjelmointikieli‰ ruvettiin kehitt‰m‰‰n varta vasten automaattisen koodin
%% generoinnin takia ja ensimm‰iset oikeasti hyˆdylliset kielet sek‰ niiden
%% k‰‰nt‰j‰t kehitettiin. 


\newpage
%
% Sitten alkaa l‰hdeluettelo
%


%ONKO LƒHDELUETTELO OK? MIKSI [1] jne?
\nocite{*}
 \bibliographystyle{apalike}
\bibliography{lahteet}

\lastpage

%\appendices

%\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

%Liitteet ovat t‰ss‰ vain sis‰llysluettelon ja esitystavan mallina.
%Jokainen liite aloitetaan yleens‰ uudelta sivulta, jonka alkuun tulee
%liitteen numero ja nimi. Kunkin liitteen sivut numeroidaan erikseen.

%Liite on paitsi dokumenttia t‰ydent‰v‰ osuus myˆs itsen‰inen
%kokonaisuus. Liite ei siten voi olla pelk‰st‰‰n kuva tai ohjelmanp‰tk‰,
%vaan liitteess‰ on ilmaistava sen sis‰llˆn laatu ja tarkoitus.


\end{document}
