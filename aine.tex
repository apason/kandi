\documentclass[finnish]{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{float}

\usepackage[round,authoryear,sort]{natbib}
\setcitestyle{notesep={: }}

\begin{document}
\onehalfspacing
%l‰hdeluettelo oikeaan formaattiin
%\makeatletter
%\renewcommand\@biblabel[1]{[#1]}
%\makeatother

\title{otsikko}
\author{Arttu Kilpinen}
\date{\today}
\level{Kandidaatintutkielma}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua}
\classification{\protect{\ \\
Software and its engineering $ \rightarrow $ software notations and tools $ \rightarrow $ Compilers}}

\keywords{Historia, K‰‰nt‰j‰t, Symbolinen konekieli, Ohjelmointikielet, Ketjutus, Ristiink‰‰nt‰minen, V‰likielet}


%BURKS 51 MAININTA INTERMEDIATESTA
%KNUTH 64 backus naur form
%RA 73
%ROSEN 64
\begin{abstract}

Symboliset konekielet olivat ensimm‰isi‰ laitteistojen ymm‰rt‰mist‰ konekielist‰ 
poikkeavia ohjelmointikieli‰. Niiden k‰‰nt‰j‰t, assemblyk‰‰nt‰j‰t, k‰‰nt‰v‰t symbolisille
konekielille kirjoitettuja ohjelmia konekielisiksi ohjelmiksi. Nykyisin k‰ytˆss‰ olevat
korkean tason ohjelmointikielet kehittyiv‰t hiljalleen ja syrj‰yttiv‰t
symbolisella konekielill‰ ohjelmoinnin l‰hes kokonaan. 

Ensimm‰iset k‰‰nt‰j‰t tehtiin tarkasti tietylle l‰hde- ja kohdekielelle.
Myˆhemmin yleistyi k‰yt‰ntˆ, jossa k‰‰nnet‰‰n jonkin v‰likielen
kautta. V‰likieli‰ k‰ytt‰en k‰‰nt‰j‰n rakenne on jaettu v‰likielen
k‰‰nnˆksest‰ vastaavaan etuosaan sek‰ konekielen tuottamisesta
vastaavaan takaosaan.
V‰likielten ja ristiink‰‰nt‰misen kehitys
helpotti myˆs k‰‰nt‰jien ketjuttamista uusille
laitteistoille.

\end{abstract}

\mytableofcontents



% mit‰ k‰sitell‰‰n, miten ja mit‰ tuloksia on saatu?
%johdanto aloitetaan asettelemalla tutkimus asiayhteyteens‰
%mink‰laisessa yhteydess‰ tarkasteluun otettavat haasteet esiintyy.
%kerro yleistajuisessa muodossa koko kirjoitelman kysymyksenasettelu juoni tulokset ja johtop‰‰tˆkset.
\section{Johdanto}
% nopea johdanto ja m‰‰ritelm‰t
K‰‰nt‰j‰t ovat tietokoneohjelmia, jotka k‰‰nt‰v‰t l‰hdekielisen ohjelmakoodin
kohdekieliseksi ohjelmaksi~\cite[1]{Bauer74}.
Ohjelmointikielet sek‰ niit‰ ymm‰rt‰v‰t k‰‰nt‰j‰t ja tulkit ovat keskeisess‰ asemassa
ohjelmistotuotannossa. K‰‰nt‰j‰t mahdollistavat ohjelmien
kirjoittamisen korkean tason ohjelmointikielill‰ sek‰ symbolisilla konekielill‰.

% Johdatus assyk‰‰nt‰jiin ja korkean tason kieliin
Ennen korkean tason ohjelmointikielille kehitettyj‰
k‰‰nt‰ji‰ oli k‰ytˆss‰ vain symbolisia konekieli‰ ymm‰rt‰vi‰ ohjelmia,
assemblyk‰‰nt‰ji‰. Niiden avulla ohjelmoija kykeni k‰ytt‰m‰‰n tekstuaalisia
konekielisi‰ komentoja laitteiston ymm‰rt‰mien bin‰‰risten konek‰skyjen sijaan.
N‰in ollen konekielinen ohjelmointi helpottui ja nopeutui. Myˆhemmin symbolisten
konekielten rinnalle kehittyi korkean tason ohjelmointikieli‰. Symbolisista
konekielist‰ poiketen niiden ohjelmointi oli laitteistoriippumatonta
ja niiden k‰‰nt‰minen oli huomattavasti monimutkaisempaa.

% ohjelmointikielten perustelut.
Korkean tason ohjelmointikielten sek‰ symbolisten konekielten k‰yttˆ helpottavat ja nopeuttavat ohjelmointia.
Niiden k‰ytt‰minen tekee ohjelmakoodista myˆs ymm‰rrett‰v‰mp‰‰ ja
helpompilukuista. Yleisesti ottaen ohjelmointikielen ymm‰rrett‰vyys kasvaa abstraktiotason
kasvaessa. Esimerkiksi matemaattisesti tutulla tavalla kirjoitetut aritmeettiset lausekkeet
ovat ymm‰rrett‰v‰mpi‰ kuin vastaava laskenta symbolisella konekielell‰ ohjelmoituna.
Lis‰ksi useat korkean tason ohjelmointikielet mahdollistavat --- mik‰li
tarvittavat k‰‰nt‰j‰t ovat olemassa --- saman ohjelmakoodin k‰ytt‰misen useissa eri
laitteistoissa. 

% T‰h‰n myˆs jotain introa k‰‰nnˆstekniikoista cross, bootstrap.
% v‰likielet
Laitteistojen monipuolistuessa k‰‰nt‰ji‰ tarvittiin yh‰ enemm‰n.
Ristiink‰‰nt‰misest‰, jossa k‰‰nnett‰v‰ ohjelma toimii eri laitteistolla kuin sit‰ k‰‰nnet‰‰n,
tuli suosittua. Ristiin k‰‰nt‰misen helpottamiseksi kehitettiin
v‰likieli‰. Niiden avulla tarvittavan ohjelmoinnin m‰‰r‰ saatiin pienemm‰ksi.

K‰‰nt‰jien monimutkaistuessa niiden kuvaamiseksi kehitettiin erilaisia kaavioita.
Yleisimmin k‰tetty T-kaavio kuvaa k‰‰nt‰ji‰ hyvin korkealla tasolla.
Niit‰ k‰ytt‰en voidaan kuitenkin kuvata monimutkaisiakin
rakenteita helpolla ja ymm‰rrett‰v‰ll‰ tavalla.

Ketjuttamisen, tekniikan jossa jonkin korkean tason ohjelmointikielen
k‰‰nt‰j‰ k‰‰nt‰‰ itsens‰, avulla k‰‰nt‰ji‰ voidaan kehitt‰‰ samalla
ohjelmointikielell‰ jota ne k‰‰nt‰v‰t. Yhdist‰m‰ll‰ ristiink‰‰nt‰misen
ja ketjuttamisen, voidaan k‰‰nt‰ji‰ siirt‰‰ tehokkaasti
laitteistojen v‰lill‰. 

%rakenne
Luvussa~\ref{assy} k‰sitell‰‰n assemblyk‰‰nt‰jien historiaa sek‰ toimintaa.
Korkean tason ohjelmointikielten historiaa esitet‰‰n luvussa~\ref{korkea}.
L‰pi k‰yd‰‰n merkitt‰vien kielten ja k‰‰nt‰jien kehityst‰ muutaman vuosikymmenen ajalta.
Luku~\ref{v‰likielet} k‰sittelee ristiink‰‰nt‰mist‰ ja v‰likieli‰.
T-kaaviot esitet‰‰n luvussa~\ref{t} ja niiden avulla kuvataan k‰‰nt‰jien
rakennetta sek‰ ketjuttamista luvussa~\ref{ketjutus}.
K‰‰nt‰jien tarkempi toteutus ja vaihejako, kuten syntaktinen ja semanttinen
analyysi j‰‰v‰t t‰m‰n tutkielman ulkopuolelle.


\section{Symbolinen konekieli ja assemblyk‰‰nt‰j‰t \label{assy}}
Er‰‰n m‰‰ritelm‰n mukaan assemblyk‰‰nt‰j‰ on k‰‰nt‰j‰, joka k‰‰nt‰‰
symbolisella konekielell‰ kirjoitettuja komentoja konekielisiksi komennoiksi~\cite[1]{Salomon93}.
Koska jokaisella laitteistolla on oma konekielens‰ ja t‰m‰ konekieli on myˆs ohjelmointikieli,
p‰tee yleinen k‰‰nt‰jien m‰‰ritelm‰ myˆs assemblyk‰‰nt‰jiin. L‰hdekielen‰ assemblyk‰‰nt‰j‰n
ymm‰rt‰m‰ symbolinen konekieli tarkoittaa konekielt‰, jossa laitteen ymm‰rt‰m‰t bin‰‰riset konek‰skyt
on korvattu ihmisille helpommin muistettavilla sanoilla eli symboleilla.

\subsection{Ensimm‰iset assemblyk‰‰nt‰j‰t}
Ennen symbolisten konekielten kehityst‰ ohjelmoitiin vain
laitteistoriippuvaisilla konekielill‰. Siit‰ huolimatta,
ett‰ k‰skykannat olivat nykyiseen verrattuna suhteellisen yksinkertaisia, oli ohjelmointi
hidasta ja tyˆl‰st‰. Symbolisten konekielten kehitys helpotti ohjelmointityˆt‰ ja
v‰hensi virheiden m‰‰r‰‰.

Ensimm‰iset assemblyk‰‰nt‰j‰t olivat niin sanottuja assemble-go-k‰‰nt‰ji‰,
jotka osasivat ainoastaan l‰hdekoodin k‰‰nt‰misen suoraan muistiin ja sen suorittamisen~\cite[2]{Salomon93}.
Pian ymm‰rrettiin kuitenkin tarve kohdekoodin kirjoittamiseksi tiedostoon. T‰m‰ mahdollisti
ohjelmoinnin jakamisen useaan tiedostoon sek‰ aiemmin kirjoitettujen kirjastojen k‰ytt‰misen (ibid).
Koska ennen ensimm‰isi‰ assemblyk‰‰nt‰ji‰ ei ollut mit‰‰n ohjelmointia
helpottavia tyˆkaluja, tuli ne ohjelmoida suoraan konekielell‰.
Myˆhemmin k‰‰nt‰ji‰ pystyttiin ohjelmoimaan aiempia k‰‰nt‰ji‰ apuna k‰ytt‰en ja
niihin oli helpompi lis‰t‰ ominaisuuksia.

EDSAC (electronic delay storage automatic calculator) oli yksi ensimm‰isi‰ s‰hkˆisi‰
tietokoneita. Se kehitettiin Cambridgen yliopistossa ja saatiin k‰yttˆvalmiiksi vuonna 1949~\cite[7]{Salomon93}.
EDSAC:lle kehitettiin assemblyk‰‰nt‰j‰ Initial Order, joka toimi laitteiston lukumuistissa (ROM) (ibid).
EDSAC:n kehitt‰j‰ Maurice Wilkes ehdotti ensimm‰isen‰  tunnusten (label) sek‰ makrojen
k‰yttˆ‰ symbolisten konekielten k‰‰nt‰jiin~\cite[7]{Salomon93}. Tunnusten,
joita h‰n kutsui liukuviksi osoitteiksi, avulla ohjelmoijan ei en‰‰ tarvitsisi
pit‰‰ kirjaa koodirivien osoitteista.

IBM 704/702 tietokoneet valmistuivat 1956. Niiden ensimm‰inen assemblyk‰‰nt‰j‰
UASAP-1 oli alkuun hyvin yksinkertainen. Se kykeni k‰‰nt‰m‰‰n vain
tekstuaalisia symbolisia konek‰skyj‰ yksi yhteen ennalta m‰‰r‰ttyjen
s‰‰ntˆjen perusteella~\cite[10]{Rosen64}. Myˆhemmin UASAP:iin ohjelmoitiin tuki myˆs tunnusten
ja makrojen k‰ytt‰miseksi~\cite[8]{Salomon93}.
Melwin Conwayn vuonna 1958 julkaisema UNIVAC:n assemblyk‰‰nt‰j‰ UNISAP oli ensimm‰inen, joka mahdollisti
kahden erilaisen tunnuksen k‰ytˆn, paikallisen sek‰ globaalin~\cite[37]{Salomon93}.

Korkean tason kielten k‰‰nt‰ji‰ alettiin kehitt‰‰
pian ensimm‰isten assemblyk‰‰nt‰jien valmistuttua,
mutta symbolisilla konekielill‰ ohjelmointi pysyi pitk‰‰n suosiossa.
Vaikka nykyaikaiset korkean tason ohjelmointikielien k‰‰nt‰j‰t tuottavat %l‰hde t‰h‰nkin
hyvin optimoitua koodia, on hyv‰n ohjelmoijan kirjoittama symbolinen
konekieli silti usein tehokkaampaa. T‰m‰n takia symbolisia %LƒHDE PYYDETTY
konekieli‰ k‰ytet‰‰n jonkin verran matalan tason ohjelmoinnin lis‰ksi
suurta laskentatehoa vaativien ohjelmien optimointiin.

\subsection{Assemblyk‰‰nt‰jien toiminta}
%avaus
Assemblyk‰‰nt‰j‰t ymm‰rt‰v‰t jotakin symbolista konekielt‰ ja
tuottavat t‰st‰ konekielisen ohjelman. %pit‰s eka linkkaa
Symboliset konekielet ovat matalan tason laiteriippuvaisia ohjelmointikieli‰.
Niit‰ k‰‰nnet‰‰n l‰hdekoodista yksinkertaisin, ennalta m‰‰r‰tyin ehdoin konekielelle.
Jokaisella symbolisella konek‰skyll‰ on siis yksiselitteinen vastine konekielell‰, %pit‰iskˆ viel‰ t‰sment‰‰ ett‰ opcode eik‰ koko konek‰sky
joten tietty symbolinen konekieli toimii vain tietyll‰ laitteistolla~\cite[2]{Salomon93}
Jokainen l‰hdetiedoston konek‰sky k‰‰nnet‰‰n staattisen ohjauskooditaulukon avulla,
josta etsit‰‰n symbolista konek‰sky‰ vastaava laitteiston ymm‰rt‰m‰ bin‰‰rikoodi~\cite[17]{Salomon93}.

%direktiivit
L‰hes kaikki nykyaikaiset assemblyk‰‰nt‰j‰t sis‰lt‰v‰t myˆs niin sanottuja direktiivej‰.
Pseudokomennot eli direktiivit ovat k‰‰nt‰j‰n omia komentoja, joille ei ole mit‰‰n
vastinetta laitteiston ymm‰rt‰m‰ll‰ konekielell‰. Ne vaikuttavat kuitenkin k‰‰nnettyyn
ohjelmaan jollain tavalla, esimerkiksi varaamalla tilaa muuttujina k‰ytett‰ville
muistipaikoille. Direktiivit pikemminkin suoritetaan kuin k‰‰nnet‰‰n~\cite[13]{Salomon93}. 
Jokainen l‰hdetiedoston rivi sis‰lt‰‰ joko symbolisen konek‰skyn tai direktiivin mik‰li k‰‰nt‰j‰
niit‰ tukee.
%makrot vois ehk‰ yhdist‰‰ direktiivikappaleeseen.
Jotkin assemblyk‰‰nt‰j‰t tukevat myˆs niin sanottuja makroja.
Makrot ovat oikeastaan monimutkaisia direktiivej‰, jotka ennen
varsinaista koodin k‰‰ntˆ‰ k‰sitell‰‰n ja niist‰ tuotetaan
symbolista konekielt‰~\cite[109]{Salomon93}.

%labelit
Symbolisten konekielten k‰‰nt‰minen tapahtuu suurimmaksi osaksi yksi yhteen edell‰ kuvatulla
tavalla. Poikkeuksen muodostavat tunnukset, jotka k‰sitell‰‰n ohjauskooditaulukosta
poiketen dynaamisessa muistirakenteessa. Tunnukset ovat symbolisia nimi‰ muistipaikoille.
Niiden arvot m‰‰r‰ytyv‰t vasta k‰‰nnˆksen yhteydess‰.
Tunnusten avulla muistipaikat voidaan nimet‰ eik‰ ohjelmoijan tarvitse pit‰‰
kirjaa konek‰skyjen osoitteista. Tunnuksiin sidottuja muistipaikkoja voidaan myˆs k‰ytt‰‰ muuttujina.
Useissa ohjelmointikieliss‰ on direktiivi, jolla voidaan varata muistia ja viitata
siihen tunnuksen avulla.

%selvent‰v‰ kuvaesimerkki.
Kuva~\ref{TTKesim} selvent‰‰ symbolisten konekielten m‰‰rittelemien symbolien
sek‰ ohjelmoijan m‰‰rittelemien tunnusten eron. Esimerkkikoodi on
TTK91-virtuaaliprosessorille~\cite[]{Ttk91} tehty ohjelma, joka tulostaa k‰ytt‰j‰lle kokonaisluvut
nollasta viiteen. Keltaisella pohjalla olevat symbolit ovat tunnuksia,
joilla voi olla eri arvo k‰‰nnˆskerrasta ja k‰‰nt‰j‰st‰ riippuen.
Harmaalla pohjalla oleva koodi k‰‰nnet‰‰n siis t‰ysin ennalta m‰‰r‰tysti.
Tunnukset m‰‰ritell‰‰n k‰ytt‰m‰ll‰ niit‰ konek‰skyn vasemmalle puolelle varatussa
tunnuskent‰ss‰. K‰yttˆ puolestaan tapahtuu, kun tunnukseen viitataan konek‰skyn operandina~\cite[17]{Salomon93}.

\begin{figure}[H]
  \ \newline
  \centerline{\includegraphics[scale=0.5]{esimerkkiTTK.png}}
  \caption{TTK91-esimerkkikoodi. \label{TTKesim}}
    \label{kuvaesimerkki}
\end{figure}

%% \begin{figure}[H]
%%   \ \newline
%%   \begin{center}
%%     \includegraphics[scale=0.5]{esimerkkiTTK.png}
%%     \caption{TTK91-esimerkkikoodi. \label{TTKesim}}
%%     \label{kuvaesimerkki}
%%   \end{center}
%% \end{figure}



\section{Historiaa korkean tason kielten k‰‰nt‰jist‰ \label{korkea}}

%t‰h‰n joku luonnollinen siirtym‰ assyist‰ korkeaan
Korkean tason ohjelmointikielell‰ tarkoitetaan t‰ss‰ tutkielmassa ohjelmointikielt‰,
jossa l‰hdekieli ja siit‰ k‰‰nnett‰v‰ konekieli ovat 
selke‰sti eri abstraktiotasoilla.
Toisin sanoen korkean tason ohjelmointikielell‰ viitataan kieleen, joka ei ole (symbolinen) konekieli.
Korkean tason ohjelmointikielten k‰‰nt‰minen edellytt‰‰
siis muutakin, kuin mekaanista sanojen vaihtamista ennalta m‰‰r‰ttyjen s‰‰ntˆjen perusteella.


% Kerrotaan korkean tason kielten hyˆdyist‰ ja miksi niit‰ tarvitsee
\subsection{T‰sm‰llisten kuvausj‰rjestelmien kehitys}
Tietojenk‰sittelytieteess‰ kuvataan ohjelmien suoritusta
ja algoritmeja t‰sm‰llisesti. Ennen formaaleja merkint‰tapoja ja korkean tason ohjelmointikieli‰ ainoa
t‰sm‰llinen tapa algoritmien kuvaamiseksi oli niiden kirjoittaminen konekielell‰.
Alan Turingin tunnetussa julkaisussa~\cite[]{Turing36} esitettiin 
m‰‰ritelm‰ laskenta-automaatista, joka paremmin tunnetaan Turingin koneena.
Sen yhteydess‰ m‰‰riteltiin myˆs matemaattinen formalismi, jolla automaatin
toimintaa voitiin t‰sm‰llisesti kuvailla. Vaikka esitystapa oli vaikea ja esitelty
automaatti hypoteettinen,
se edusti Alonzo Churchin merkint‰tavan~\cite[]{Church36} ohella kehittyneint‰ formaalia
laskennan kuvausta, 'kielt‰', joka siihen aikaan oli olemassa.

%PLANKAK‹L
Vuonna 1945 saksalainen Konrad Zuse aloitti
tietokoneohjelmien kuvailuun tarkoitetun kielen Plankalk¸lin kehitt‰misen~\cite[8]{Knuth76}.
Zusen sanoin Plankalk¸lin tarkoitus oli luoda puhtaasti formaali esitystapa
mille tahansa laskentaongelmalle~\cite[10]{Knuth76}.
Plankalk¸lissa voidaan m‰‰ritell‰ aritmetiikan ja ohjausrakenteiden lis‰ksi
rajaton m‰‰r‰ sis‰kk‰isi‰ tietorakenteita, ja Zusen tyˆhˆn viitataankin
usein ensimm‰isen‰ korkean tason ohjelmointikielen‰.
Vaikka kyseess‰ oli huomattavan edistyksellinen j‰rjestelm‰, se ei
kuitenkaan vaikuttanut ohjelmointikielten kehitykseen juuri lainkaan,
sill‰ artikkeli julkaistiin vasta vuonna 1972. Vaikka Plankalk¸lille toteutettiinkin
k‰‰nt‰j‰, ei sit‰ juuri koskaan k‰ytetty, koska silloin oli jo Plankalk¸lia
huomattavasti kehittyneempi‰ ohjelmointikieli‰. %err? oliks sit‰ k‰‰nt‰j‰‰ nyt vai ei??

%LOHKOKAAVIO
Samoihin aikoihin Zusen kanssa myˆs Yhdysvaltalaiset Herman Goldstine ja
John von Neumann kehittiv‰t laskennallista formalismia. Heid‰n ratkaisunsa
algoritmien ja tietokoneohjelmien kuvaamiseen oli varsin erilainen.
Von Neumann ja Goldstine esittiv‰t ratkaisuksi lohkokaaviota (flow diagram),
esitystapaa, jossa ohjelmat kuvataan nuolien ja laatikoiden avulla~\cite[16]{Knuth76}.
Lohkokaaviot esitellyt artikkeli~\cite[]{Goldstine47} saavutti suuren lukijakunnan
ja sill‰ oli suuri vaikutus ohjelmointikielten kehitykseen~\cite[16]{Knuth76} .


%CURRYN PASKA
%CU50', CU48, CU50 %VITTU KOKO Tƒƒ CURRY ON WIKLAN MIELEST PASKAA PISTETƒƒ UUSIKS
Vuonna 1946 Marylandissa tyˆskennellyt Haskell B. Curry kehitti ENIAC-tietokoneelle
aikaansa n‰hden monimutkaista ohjelmaa. Curryn tyˆ ENIAC:n
parissa sai h‰net ehdottamaan formalismia ohjelmistojen toiminnalle.
H‰nen formalisminsa perustui uuteen ajatukseen ohjelman suorituksen
lohkomaisesta rakenteesta. N‰it‰ itsen‰isesti suoritettavia osia h‰n nimitti divisiooniksi~\cite[34]{Curry50}.
Divisioonat tulisi rakentaa siten, ett‰ niiden laskenta olisi
toisistaan riippumatonta. T‰m‰n voisikin rinnastaa esimerkiksi
C-kielen paikallisiin tietorakenteisiin ja k‰‰nnˆsyksikˆihin perustuvaan
suoritukseen. Curryn formalismi oli kuitenkin hieman luonnoton,
sill‰ suoritusyksikˆill‰ oli useita lopetuskohtia sek‰ nykykielist‰ poiketen
useita aloituskohtia~\cite[21]{Knuth76}.
Historiallisesti tyˆ oli kuitenkin merkitt‰v‰, sill‰ se sis‰lsi algoritmeja
joilla kuvauksesta pystyttiin tuottamaan konekielt‰. N‰it‰ rekursiivisia
--- vaikkakin toteuttamatta j‰‰neit‰ --- algoritmeja voidaankin pit‰‰ ensimm‰isin‰ %no oliks niit algoritmei edes??
koodin generointiin tarkoitettuina algoritmeina. % t‰‰ kohta nyt on ihan vitun ripulia

%% -actually the main feature of interest in currys earlier work is not this programming language but rather the algorithms
%% hediscussed for converting parts of it into machine language. he gave a recursive description of a procedure to convert
%% faifly general arithmetic
%% expression into code for a one address compuiter thereby being the first person to describe the code generation phase of a compiler
%% syntaksin tarkastusta ei kuitenkaan ollut vaan k‰‰nt‰j‰? oletti sen olevan ok. mik‰ vitun k‰‰nt‰j‰?


\subsection{Kohti ensimm‰isi‰ k‰‰nt‰ji‰}

Millek‰‰n aiemmin mainituista ohjelmointikielist‰ ei niiden julkaisun yhteydess‰
toteutettu k‰‰nt‰ji‰. N‰m‰ kielet toimivat ohjelmoijien k‰sitteellisen‰ apuna auttaen
ohjelmien suunnittelussa, mutta j‰tt‰en toteutuksen ihmisille. T‰st‰ huolimatta
ne olivat merkitt‰vi‰ askeleita kohti parempia ohjelmointikieli‰ sek‰
niiden k‰‰nt‰ji‰. Ilman t‰sm‰llisi‰ esitystapoja ei koodin generointi, eli
varsinainen k‰‰nnˆksen tai tulkkauksen suorittaminen, ikin‰ olisi voinut tulla mahdolliseksi.

% MAUCHLY 
Ensimm‰inen korkean tason ohjelmointikieli joka toteutettiin oli Short Code.
Sit‰ kehitti John W. Mauchly ja William F. Schmitt toteutti sille tulkin vuonna 1949~\cite[23]{Knuth76}.
Tulkki toimi alkuun BINAC-tietokoneella, mutta se ohjelmoitiin myˆhemmin myˆs UNIVAC:lle.
Yksityiskohtia Short Coden toiminnasta ei ikin‰ julkaistu, joten sen tarkemmasta
toiminnasta ei ole tietoa. Vuonna 1955 julkaistussa ohjelmoijille tarkoitetussa
manuaalissa kerrotaan kuitenkin kuinka ohjelmaa voidaan k‰ytt‰‰. % RR55 Ei lˆydy
Short Code oli siis algebrallinen tulkki, joka osasi suorittaa aritmeettisia %mik‰ vittu on algebrallinen tulkki t. wikla
laskutoimituksia ilman konekielist‰ ohjelmointia. Ohjelma luki syˆtett‰ ja
tulkkasi vastaavat toiminnot ajetulle laitteistolle.

% RUTISHAUER & B÷HM
1950-luvun alussa Heiniz Rutishauser ja Corrado Bˆhm tyˆskenteliv‰t Z¸richin
teknillisess‰ yliopistossa Sveitsiss‰. Vaikka he tyˆskenteliv‰t samassa paikassa
ja saman aiheen parissa, he tekiv‰t tˆit‰ itsen‰isesti. Rutishauser julkaisi
vuonna 1952 artikkelin, jossa h‰n kuvasi hypoteettisen tietokoneen sek‰ siin‰ toimivan
k‰‰nt‰j‰n kehitt‰m‰lleen ohjelmointikielelle~\cite[30]{Knuth76} . Julkaisu oli merkitt‰v‰, sill‰
siin‰ kuvattiin ensimm‰ist‰ kertaa menetelm‰ k‰‰nt‰jien toteuttamisesta
sek‰ koodin generoinnista (ibid). % mit‰ eroa curryn algoritmeihin n‰hden?? RU52

Myˆs Corrado Bˆhm kehitti samaan aikaan itsen‰isesti ohjelmointikielt‰ sek‰
t‰m‰n k‰‰nt‰j‰‰. H‰nen julkaisunsa oli Rutishauserin julkaisua viel‰kin
merkitt‰v‰mpi, sill‰ h‰n oli toteuttanut k‰‰nt‰j‰n omalla kielell‰‰n~\cite[36]{Knuth76}.
Bˆhmin kieli ei kuitenkaan osannut k‰sitell‰ muita kuin positiivisia
kokonaislukuja, joten sen k‰yttˆarvo j‰i melko pieneksi. K‰‰nt‰jien
teorian kehityksen kannalta se oli kuitenkin korvaamaton. Bˆhmin k‰‰nt‰j‰
kykeni tarkistamaan koodin syntaksia lineaarisessa ajassa, kun Rutishauserin
k‰‰nt‰j‰ puolestaan toimi neliˆisess‰ ajassa~\cite[40]{Knuth76}. Lis‰ksi Bˆhmin k‰‰nt‰j‰ hallitsi matemaattisten
operaattoreiden sidontaj‰rjestyksen, sek‰ osasi k‰sitell‰ sulkeita aritmeettisissa 
lausekkeissa. Bˆhm oli myˆs ensimm‰inen, joka todisti 
matemaattisesti ohjelmointikielens‰ voivan laskea mink‰ tahansa laskettavan funktion~\cite[42]{Knuth76}.
%rutishauser and bˆhm had had a considerable advantage over glennie in that they had designed theri own machine code


% VITTU MITƒ PASKAA
Vaikka Rutishauser ja Bˆhm olivat kumpikin valmistaneet %vittu oliko??
omat k‰‰nt‰j‰ns‰, pidet‰‰n ensimm‰isen‰ oikeana k‰‰nt‰j‰n‰ silti
Alick E. Glennien 1952 valmistamaa AUTOCODE-ohjelmistoa~\cite[42]{Knuth76}. Aiemmista k‰‰nt‰jist‰ poiketen
AUTOCODE ei toiminut hypoteettisella laitteistolla joten sen tuottama konekieli
oli t‰ten suoritettavissa. AUTOCODEa pystyttiin siis k‰ytt‰m‰‰n oikeiden,
k‰yttˆkelpoisten ohjelmien tekemiseen~\cite[42]{Knuth76}.

%% --- vaikka olikin kokeneille ohjelmoijille tarkoitettu~\cite[Knuth74]
%% --- k‰ytettiin, kuten tarkoitus oli, oikeaan ohjelmointiin.

%FORTRAN T‰‰ koko fortran on aika perseest‰ kans..
Vuoden 1954 alussa John Backus rupesi kehitt‰m‰‰n kokoamansa kehitt‰j‰ryhm‰n kanssa
automaattisen ohjelmoinnin j‰rjestelm‰‰. J‰rjestelm‰n oli tarkoitus olla hyvin
kehittynyt, joten suureksi haasteeksi muodostui j‰rjestelm‰n saaminen tarpeeksi
tehokkaaksi. Loppuvuodesta 1954 kehitt‰j‰ryhm‰ julkaisi suunnitelman j‰rjestelm‰st‰ 'The IBM %LƒHTEET t. wikla
Mathematical FORmula TRANstating system' --- FORTRAN. 
Ryhm‰n julkaisu alkoi painottamalla sit‰ tosiasiaa, ett‰ FORTRAN oli tehokas. Aiemmin ohjelmoijien tuli
valita helpon ohjelmoinnin ja hitaan suorituksen tai tyˆl‰‰n ohjelmoinnin ja nopean
suorituksen v‰lilt‰, mutta julkaisun j‰lkeen FORTRAN tarjoaisi parhaat
puolet molemmista~\cite[1]{IBM54}. %IB54 EN OO VIEL LUKENU MUT MENK÷÷
FORTRAN 0-dokumentti sis‰lt‰‰ myˆs ensimm‰isen yrityksen esitt‰‰ ohjelmointikielen %mik‰ vittu on fortran 0 ;:DD
kielioppi t‰sm‰llisesti. T‰t‰ voidaan pit‰‰ Backuksen myˆhemmin esitt‰m‰n kielioppimuodon
Backus Naur Formin (BNF) edelt‰j‰n‰.
%ei oltu viel‰ implementoitu. Tyˆhen meni 2.5 vuotta!!!

Kun FORTRAN kaksi ja puoli vuotta myˆhemmin saatiin toteutettua, oli se
aikansa tehokkain sek‰ monipuolisin ohjelmointikieli. Se tuotti %siis fortranin k‰‰nt‰j‰t. kankeesti sanottu.
suhteellisen tehokasta koodia ja kehitt‰j‰t sanoivat sen olevan l‰hes
yht‰ tehokasta kuin hyv‰n ohjelmoijan kirjoittama symbolinen konekieli~\cite[1]{IBM56}.
FORTRANissa oli myˆs paljon ominaisuuksia, joita ei oltu aiemmin n‰hty.
Se oli esimerkiksi ensimm‰inen ohjelmointikieli, jossa muuttujien nimet
voivat olla useamman merkin pituisia~\cite[62]{Knuth76}. %ent‰ ass kielten tunnukset t. wikla

Ensimm‰isen julkaisun j‰lkeen FORTRANissa oli kuitenkin useita ongelmia.
Virheit‰ oli paljon, ja er‰s FORTRAN:n kehitt‰jist‰, Saul Rosen, %OLIKO SAUL ROSEN kehitt‰j‰!?
%OLIKO bugeja edes paljon vai viitattiinko tossa aikaan ennen julkaisua perkele?!
sanoikin ettei uskonut FORTRAN:n ikin‰ tulevan toimimaan~\cite[4????]{Rosen64}.
Vaikeuksista huolimatta FORTRAN:sta tuli hyvin suosittu ja sit‰ k‰ytettiin
enemm‰n kuin oltiin osattu odottaa.

Taulukko 1 tiivist‰‰ aiemmissa kappaleissa esiteltyjen ohjelmointikielten merkitt‰vimm‰t
piirteet. Lis‰ksi taulukossa esitell‰‰n ohjelmointikielten nimet sek‰ p‰‰tekij‰t.

\begin{table}[h!]
  \centering
  \caption{Yhteenveto ohjelmointikielten kehityksest‰ ~\cite[93]{Knuth76}.} 
  \label{tab:table1}
  \begin{tabular}{| l | l | l |}
    \hline
    \textbf K\textbf i\textbf e\textbf l\textbf i & \textbf K\textbf e\textbf h\textbf i\textbf t\textbf t\textbf ‰\textbf j\textbf ‰\textbf  & \textbf E\textbf n\textbf s\textbf i\textbf m\textbf m\textbf ‰\textbf i\textbf n\textbf e\textbf n \\ \hline
    Plankalk¸l & Zuse & Ohjelmointikieli, Hierarkkinen data \\ \hline
    Virtauskaaviot & Goldstine, & Hyv‰ksytty ohjelmointimenetelm‰ \\
     & Von Neumann &  \\ \hline
    Short Code & Mauchly & Toteutettu korkean tason ohjelmointikieli \\ \hline
    Formules & Bˆhm & K‰‰nt‰j‰ omalla kielell‰‰n \\ \hline
    AUTOCODE & Glennie & K‰yttˆkelpoinen k‰‰nt‰j‰ \\ \hline
    FORTRAN I & Backus & I/O formaatti, kommentit, globaali optimointi \\ \hline
  \end{tabular}
\end{table}

%% Almost to a ma nthey firmly believed that any mechanical coding method would fail to apply that versatile ...
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -57
%% -paljon tuntemattomia projekteja sill‰ olivat niin edistyksellisi‰ ettei tutkimustuloksia ikin‰ julkaistu.

%% -Alick glennie AUTOCODE 1952
%% -yleisesti pidet‰‰n ensimm‰isen‰ ``oikeana'' ``kunnon'' k‰‰nt‰j‰n‰.-
%% - glennie sanoin 1953: to  make it easy one must make coding  comprehensible. this may be done only by improving the
%% notation of programming., aikaisemmat notaatiot ovat ongelmallisia.
%% ‰- autocode was still very machine oriented.
%% - autocode oli t‰rke‰ askel eteenp‰in  vaikka olikin machine oriented ja tarkoitettu kokeneille ohjelmoijille

%% TƒHƒN MENNESSƒ kukaan ei ollut k‰ytt‰nyt viel‰ termi‰ k‰‰nt‰j‰. termin‰ oli automaattinen koodausw (automatic coding)
%% sitten sit‰ k‰ytettiin


%% -1954 John Backus tyˆskenteli ibm tehd‰kseen paremman systeemin automaattisesta ohjelmoinnista BA 76
%% -suuri ongelma oli tehokkuus. L‰hes kaikki alalla uskoivat ett‰ any mechanical coding method would fail apply that
%% versatile ingenuity which each programmer felt he possessed and vonstantly neededi nhis gwork.
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -by november 1954 bakusin ryhm‰ oli speksannu the ibm mathematical formula translating system FORTRAN.

%% ensimm‰inen paragrafi IB 54 t‰hdensi ett‰ aiemmat systeemit olivat tarjonneet vaihtoehdoiksi helpon ohjelmoinnin ja
%% hitaan suorituksen tai tyˆl‰‰n ohjelmoinnin ja nopean suorituksen. mutta fortranilla molemmat olivat mahdollisia.

%% fortran oli enswimm‰inen kieli miss‰ muuttujalla voi olla useamman merkin nimi.

%% -fortran 0 dokumentti esitteli ensimm‰isen yrityksen m‰‰ritell‰ ohjelmointikielen syntaksi t‰sm‰llisesti. bakusin t‰rke‰ huomio
%% BA 95 mist‰ tuli BNF voidaan n‰hd‰ tulevan t‰‰lt‰.



%% -assemblyien suosio pysyi esim koska esim x k‰‰nt‰j‰n optimointi oli paska. vain 50% tehokas

% ensimm‰inen k‰‰nt‰j‰ vasta 1975 Joachim Hohmann: Der Plankalkul im Vergleich mit algorithmischen Sprachen. Reihe Informatik und Operations Research, S. Toeche-Mittler Verlag, Darmstadt 1979, ISBN 3-87820-028-5161.
% ensimm‰inen 'useful' 'real' compiler, knuth 77 - sivu 42.
%% \section{tekniikkaa}
%% \subsection{bootstrapping}
%% \subsection{cross compiling}
















%% However one could discuss how an existing compiler could propagate an image of itself to another machine.
%% This technique popularly referred to as bootstrapping or cross compiling~\cite{Reynolds03}.

%% A conventional C compiler, written in C, is said to be bootstrapped if it compiles itself.
%% Now suppose a new version of the compiler source is weirren, that uses different registers for passing arguments.
%% The old compiler can compile this source, yelding a new compiler. But Look! The executable version cc'
%% of the new compiler uses the old parameter passing style, but generates code that uses the new style.
%% onecan use the new compiler however to recompile all the libraries and the new version itself
%% and get a new new executable thet both uses and generates the new parameter passing style~\cite{Appel94}.


%% -intermediate language as a tool to reduce duplivaton of effort.
%% -t‰m‰n takia cross compilation saanut paljon huomiota.
%% -cc on prosessi of one machine accepting a source program as input and producing an object code thet is executable on another machine.
%% -ongelma k‰‰nt‰jien m‰‰rien kanssa, siksi IL.
%% -Saanut alkunsa UNCOLsta
%%~\cite{Speetjens76}.

%BURKSILLA OLI MY÷S INTERMEDIATE LANGUAGE!
\section{V‰likielet ja ristiink‰‰nt‰minen \label{v‰likielet}}
Jo 1950-luvun lopulla sek‰ k‰ytett‰viss‰ olevien ohjelmointikielten ett‰ erilaisten laitteistojen
m‰‰r‰ oli kasvanut merkitt‰v‰sti. Korkean tason ohjelmointikielill‰
ohjelmoinnista oli tullut yleist‰ ja sen hyˆdyt olivat laajalti tunnettuja~\cite[12]{Strong58}.
Uusien laitteistojen kehitys oli nopeaa ja tyypillisesti laitteistoja uusittiin
viimeist‰‰n viiden vuoden v‰lein (ibid). Vaikka korkean tason ohjelmointikielten
k‰yttˆ v‰hensi tarvetta sovellusten uudelleenohjelmoinnille, muodostui k‰‰nt‰jien
kehitys merkitt‰v‰ksi ongelmaksi. Tehokkaan k‰‰nt‰j‰n kehitt‰miseen kuluva
aika oli samaa suuruusluokkaa laitteistojen k‰yttˆi‰n kanssa,
joten hyvien k‰‰nt‰jien valmistuttua oli laitteisto usein jo vanhentunut (ibid).
Ongelmaa koitettiin v‰ltt‰‰ erilaisilla k‰‰nnˆstekniikoilla. Yleiseksi tavaksi
muodostui ristiink‰‰nt‰minen uusille laitteistoille.

%laitetaanko t‰h‰n v‰liotsikko vai ei?
\subsection{Ristiink‰‰nt‰minen}
%https://www.gnu.org/savannah-checkouts/gnu/automake/manual/html_node/Cross_002dCompilation.html
Tavallisesti tietokonej‰rjestelmiss‰ k‰ytett‰v‰t k‰‰nt‰j‰t tuottavat konekielt‰ samalle
laitteistolle, jossa niit‰ suoritetaan. Ristiink‰‰nt‰misell‰ (cross compiling) tarkoitetaan
sit‰, ett‰ kohdelaitteisto on jokin muu kuin k‰‰nnˆst‰ suorittava laitteisto~\cite[]{GNU16}.
Ristiink‰‰nt‰misen mahdollistamiseksi tarvitaan siis k‰‰nt‰ji‰, jotka tuottavat konekielt‰
uudelle laitteistolle. N‰m‰ ohjelmoidaan vanhalla laitteistolla jo olemassa olevia
ohjelmointikieli‰ k‰ytt‰en. T‰ten saaduilla ristiink‰‰nt‰jill‰ pystyt‰‰n k‰‰nt‰m‰‰n
k‰‰nt‰ji‰ tai muita ohjelmia, jotka toimivat uudessa laitteistossa.

%miten toi pilkku nyt menee?
Ongelmana edell‰ mainitussa menetelm‰ss‰ on suuri sek‰ kasvava joukko l‰hde- ja
kohdekieli‰. Jo yhden uuden k‰‰nt‰j‰n toteuttaminen on varsin tyˆl‰st‰, joten uuden k‰‰nt‰j‰n
tekeminen kaikille halutuille laitteistoille vaatisi valtavasti resursseja.
Oletetaan, ett‰ korkean tason ohjelmointikielten m‰‰r‰ on $N$ ja laitteistojen m‰‰r‰ on $M$.
T‰llˆin tarvittavien k‰‰nt‰jien m‰‰r‰ on $N \cdot M$, joka kasvaa neliˆisesti kohde- ja l‰hdekielien
kasvaessa. Kuva~\ref{nxm} esitt‰‰ tilannetta jossa on k‰‰nt‰j‰t kuudelle eri ohjelmointikielelle
viiteen eri laitteistoon. 
%loppuuko t‰‰ kappale v‰h‰n tˆnkˆsti?

\begin{figure}[H]
	\ \newline
	\begin{center}
          \hbox{\vspace{-5cm} \includegraphics[scale=1.0]{NxM.png}}
%		\includegraphics[scale=1.0]{NxM.png}
		\caption{Ristiink‰‰nt‰minen usealta l‰hdekielelt‰ usealle kohdekielelle.~\cite[378]{Steel61} \label{nxm}}
		\label{kuvaesimerkki} % t‰‰ l‰hde on p‰in helvetti‰? jr??
	\end{center}
\end{figure} 

\subsection{V‰likielet}
Mik‰li olisi olemassa sellainen ohjelmointikieli, jolle olisi toteutettu k‰‰nt‰j‰ kaikille
mahdollisille laitteistoille, voitaisiin korkean tason ohjelmointikielet k‰‰nt‰‰
mille tahansa laitteistolle t‰t‰ kielt‰ apuna k‰ytt‰en. T‰llaisella menetelm‰ll‰
tarvittavien k‰‰nt‰jien m‰‰r‰ v‰henisi huomattavasti. Uudet ohjelmointikielet saataisiin
toimimaan mill‰ tahansa laitteistolla vain yhden uuden k‰‰nt‰j‰n avulla. Uuden ohjelmointikielen
k‰‰nt‰j‰t k‰‰nt‰isiv‰t niit‰ kyseiselle v‰likielelle, josta se voitaisiin jo olemassa olevien
k‰‰nt‰jien avulla k‰‰nt‰‰ mille tahansa laitteistolle.

Idea tunnettiin alun perin nimell‰ UNCOL (UNiversal Computer Oriented Language)~\cite[14]{Strong58}.
UNCOL ei ollut niink‰‰n suunniteltu ohjelmointikieli, vaan pikemminkin idea v‰likielest‰,
jonka avulla k‰‰nt‰ji‰ voisi toteuttaa pienemm‰ll‰ vaivalla. Siit‰ puhuttiin jo vuonna
1954, eik‰ konseptin alkuper‰ist‰ keksij‰‰ tunneta (ibid).

Mik‰li jonkinlainen UNCOL --- kaikkien k‰‰nt‰jien tuntema v‰likieli --- olisi olemassa,
v‰henisi ristiink‰‰nt‰miseen tarvittavien k‰‰nt‰jien m‰‰r‰ huomattavasti. Jos
ohjelmointikielten m‰‰r‰ on $N$ ja laitteistojen m‰‰r‰ $M$, tarvittaisiin t‰llaisessa
v‰likieliratkaisussa vain $N+M$ k‰‰nt‰j‰‰~\cite[15]{Speetjens76}. Toisin sanoen k‰‰nt‰jien m‰‰r‰ kasvaisi
lineaarisesti ohjelmointikielten ja laitteistojen suhteen. Kuvassa \ref{n+m} esitet‰‰n
tilanne v‰likielen avulla. 

\begin{figure}[H]
	\ \newline
	\begin{center}
%           \hbox{\vspace{-15cm} \includegraphics[scale=1.0]{N+M.png}}
		\includegraphics[scale=1.0]{N+M.png}
		\caption{Ristiink‰‰nt‰minen v‰likielill‰.~\cite[378]{Steel61} \label{n+m}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure} 

UNCOL:ksi on ehdotettu useita eri v‰likieli‰, mutta yhdest‰k‰‰n ei ole tullut
niin k‰ytetty‰, ett‰ sit‰ voitaisiin sanoa universaaliksi. Er‰s UNCOL:ksi ehdotettu
kieli oli Melvin Conwayn 1958 julkaisema v‰likieli. Conwayn julkaisussa
\emph{Proposal for an UNCOL}
m‰‰ritell‰‰n matalan tason v‰likieli, jota h‰n kutsuu SML:ksi (Simple Machine Language)~\cite[5]{Conway58}.
%miks vitus toho ei tuu v‰lii

%mitetit‰‰s n‰it‰ kahta viimest‰ paragrafia viel‰. j‰lkˆll‰ oli pointtia. 
Kaikilla laitteilla toimivan v‰likielen tulisi olla t‰ysin laitteistoriippumaton. 
Laitteistoriippumattomalla kielell‰ tarkoitetaan, ett‰ se voidaan k‰‰nt‰‰ tehokkaasti
mille tahansa laitteistolle~\cite[1060]{Brown72}. Koska erilaisia laitteistoja
on hyvin suuri m‰‰r‰, ei mik‰‰n kieli ole t‰ysin laitteistoriippumaton (ibid).
N‰in ollen kaikille laitteistoille k‰‰nnett‰v‰n v‰likielen toteutus on
melko utopistista. Useat laitteistot ovat kuitenkin tarpeeksi samankaltaisia
tehokkaan v‰likielen kehitt‰miseksi, mik‰li tavoiteltujen kohdelaitteistojen
m‰‰r‰‰ pienennet‰‰n. Suurin osa eniten k‰ytetyist‰ tietokoneista toimii
niin samankaltaisesti, ett‰ hyv‰ v‰likieli kykenee kattamaan niist‰ suurimman osan (ibid).


%t‰h‰n v‰liin ett‰ speetjens ehdotti UMCOLia.

Vaikka v‰likielet ovat usein laitteistol‰heisi‰ ja ne k‰‰nnet‰‰n suoraan jollekin
konekielelle, voisi v‰likieli teoriassa olla hyvinkin korkeatasoinen. Jos jollekin
laitteistolle on olemassa hyv‰ jonkin korkean tason ohjelmointikielen k‰‰nt‰j‰,
voisi v‰likieli olla myˆs korkean tason ohjelmointikieli, jonka kohdekielen‰
ei olisi mik‰‰n konekieli vaan kyseinen toinen korkean tason ohjelmointikieli~\cite[1060]{Brown72}.
Koska t‰llainen tekniikka tuottaa k‰yt‰nnˆss‰ aina tehotonta koodia,
k‰‰nnet‰‰n v‰likielet l‰hes poikkeuksetta, vaikka olisivatkin korkean tasoisia
ohjelmointikieli‰, suoraan konekieliksi (ibid).



%% ...
%% Vaikka mist‰‰n ei tullut universaalia, vaikutti idea kuitenkin v‰likieltenb kehitykseen..
%% t‰h‰n ehk‰ jotain noita vitun erilaisia v‰likieli‰? vai tulisko sitteki kappaleen alkuun?


%% %ei lˆydy hyv‰‰ l‰hdett‰? ent‰: http://www.pcmag.com/encyclopedia/term/45156/intermediate-language
%% %V‰likielill‰ tarkoitetaan ohjelmointikieli‰, joka on kehitetty toimimaan v‰livaiheena
%% %k‰‰nnˆsprosessissa korkean tason ohjelmointikielilt‰ konekielille. V‰likielten avulla

%% -abstract machine modeling ei ihan sama asia koska voi olla korkean tason v‰likieli‰.
%% -voi olla matalan tai korkean tason tai jotain v‰lilt‰.
%% -tunnettu pitk‰n aikaa -54 ainakin.
%% - since introduction of uncol large number of il have been proposed
%% - ovat usein kehitetty for system development eik‰ cross compiling ne kaikki perustuu abstract machine modeling konseptiin
%% - erilaisia: machine oriented, problem oriented, hierarcicalk, combinational

%Bootstrapping menetelm‰‰ k‰ytet‰‰n usein myˆs ristiink‰‰nt‰misess‰ (cross compiling)
%joten kyseinen luku k‰sittelee osittain myˆs sit‰.
\section{K‰‰nt‰jien kuvaus: T-kaaviot \label{t}}

K‰‰nt‰jien suunnittelussa ja mallintamisessa on k‰ytetty useita erilaisia merkint‰tapoja.
K‰ytetyin ja tunnetuin lienee Harvey Bratmanin 1961 ehdottama T-kaavio. 
H‰n kehitti sen~\cite[]{Strong58}-julkaisussa eisteltyn UNCOL-kaavion korvaajaksi~\cite[]{Bratman61}. 
%pit‰‰ viel‰ kehitt‰‰. mutta totta ettei voi vaan sanoa uncol kaavio ja olla viittaamatta mihink‰‰n.

\subsection{Alkuper‰inen Bratman-kaavio}
Harvey Bratmanin esittelem‰ kaavio kuvaa yksitt‰ist‰ k‰‰nt‰j‰‰. 
Siit‰ k‰y ilmi k‰‰nt‰j‰n ymm‰rt‰m‰ kohde- ja l‰hdekieli sek‰ kieli, jolla k‰‰nt‰j‰ toimii.
Kaaviota kutsutaan Bratman-kaavioksi tai T-kaavioksi. J‰lkimm‰inen nimi tulee kaavion
muodosta, jossa T-kirjaimen muotoisessa alueessa vasempaan p‰‰tyyn merkit‰‰n l‰hdekieli,
oikeaan p‰‰tyyn kohdekieli ja alaosaan kieli jolla k‰‰nt‰j‰ toimii.

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{basic-T.png}
\caption{T-kaavio, joka kuvaa x86-arkkitehtuurilla toimivaa C-k‰‰nt‰j‰‰, jonka kohdekieli on x86-konekieli. \label{basic-t}}
\label{kuvaesimerkki}
\end{center}
\end{figure}

Kaavioita toisiinsa liitt‰m‰ll‰ voidaan havainnollistaa monimutkaisiakin k‰‰nt‰jill‰
suoritettavia toimintaketjuja. Kuvassa \ref{multi-t} oletetaan, ett‰ k‰ytˆss‰ on C-kielinen
k‰‰nt‰j‰, joka k‰‰nt‰‰ Ada-kielt‰ x86-konekielelle. Lis‰ksi k‰ytˆss‰ on kuvan \ref{basic-t} 
x86-arkkitehtuurilla toimiva C-k‰‰nt‰j‰, jonka kohdekieli on x86-konekieli.
N‰iden kahden k‰‰nt‰j‰n avulla voidaan tuottaa x86-alustalla suoritettava Ada k‰‰nt‰j‰,
jonka kohdekieli on x86. Kahden ensimm‰isen k‰‰nt‰j‰n yhteistyˆll‰ saadaan siis kolmas
k‰‰nt‰j‰. Huomattavaa on, ett‰ kaavion alin k‰‰nt‰j‰ toimii aina jossakin todellisessa laitteistossa,
eik‰ t‰ten voi olla muu kuin laitteiston ymm‰rt‰m‰ konekieli.

%T‰h‰n v‰liin j‰‰ vittumaisesti tyhj‰‰ tilaa

\begin{figure}[H]
  \ \newline
  \begin{center}
    \includegraphics[scale=0.5]{multi-T.png}
    \caption{C-kielisen Ada-k‰‰nt‰j‰n ja x86:lla toimivan C k‰‰nt‰j‰n avulla voidaan tuottaa x86:lla toimiva ada-k‰‰nt‰j‰. \label{multi-t}}
    \label{kuvaesimerkki}
  \end{center}
\end{figure}

\subsection{Earleyn ja Sturginsin merkint‰tapa}
T-kaavio on melko yksinkertainen, joten siit‰ on kehitetty paranneltuja vaihtoehtoja.
Jay Earley ja Howard Sturgis laajensivat Bratmanin kaaviota lis‰‰m‰ll‰ siihen ominaisuuksia~\cite[607-616]{Earley70}.
Alkuper‰isen T-kaavion kuvatessa vain k‰‰nt‰ji‰, Earleyn ja Sturgisin kaavioissa pystyy
kuvaamaan myˆs tulkkeja. Lis‰ksi niihin sis‰llytettiin suoritusta sek‰ sovellusohjelmaa kuvaava osa.
Heid‰n kaavioissaan m‰‰ritell‰‰n kuvan \ref{t-laajennos}
mukaiset elementit.

\begin{figure}[H]
  \ \newline
  \begin{center}
    \includegraphics[scale=1.0]{notations-T.png}
    \caption{Earleyn ja Sturgisin T-kaavioelementit.~\cite[282]{Mogensen10} \label{t-laajennos}}
    \label{kuvaesimerkki}
  \end{center}
\end{figure}

Kuvan vasemman puoleisin elementti vastaa Earleyn ja Sturgisin merkint‰tavassa alkuper‰ist‰ T-kaaviota.
Se kuvaa C-kielist‰ k‰‰nt‰j‰‰ joka k‰‰nt‰‰ kielelt‰ A kielelle B. Suorakaiteen muotoinen
kahdesta osasta koostuva kaavio kuvaa tulkkia, joka tulkkaa kielt‰ C ja toimii kielell‰ D.
Jotta k‰‰nnˆs voitaisiin suorittaa, tulee pohjimmaisen kielen olla suoritettavissa jollakin oikealla
laitteistolla. T‰t‰ suoritusta kuvaa yksiosainen kolmiomerkint‰. Kolmion sis‰ll‰
lukee, mill‰ konekielell‰ suoritus tapahtuu. Esimerkkikuvassa konekieli on D.
Viimeinen kaavio tarkoittaa jotain sovellusohjelmaa tai m‰‰rittelem‰tˆnt‰ laskentaa.
Kaavion sis‰ll‰ lukee ohjelmointikieli, jolla sovellus on ohjelmoitu tai jolle se on k‰‰nnetty.
Esimerkkikuvassa kieli on D~\cite[282]{Mogensen10}.

Kyseisi‰ kaavioita voi yhdistell‰ hyvinkin monimutkaisiksi rakenteiksi. Kuvan \ref{yhdistelma-t} esimerkiss‰ on
kaavio, joka kuvaa C++-kielisen ohjelman k‰‰nt‰mist‰ x86-konekielelle. Suoritus tapahtuu
x86-laitteistolla, ja k‰‰nnˆksen tekee Pythonilla toimiva k‰‰nt‰j‰, joka tulkataan x86-laitteistossa.
Huomioitava T-kaavioiden k‰ytˆss‰ on, ett‰ kaavioiden vierekk‰isten osien kielten tulee t‰sm‰t‰
toisiinsa. Kuvan esimerkin k‰‰nnˆs ei voi ottaa l‰hdeohjelmakseen muuta kuin C++:ll‰ kirjoitetun ohjelman.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{example-Earley-T.png}
		\caption{Esimerkki Earleyn ja Sturgisin kaavioiden yhdistelemisest‰. \label{yhdistelma-t}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}


%T‰h‰n lukuun tulee osittain myˆs cross compiling juttuja. Cross compilingiss‰ kerrotaan enemm‰n IL pohjaisesti
\section{K‰‰nt‰jien rakenne ja ketjutus \label{ketjutus}}
%t‰h‰n menness‰ l‰htein‰ l‰hinn‰ Mogensen ja Appel
Koska k‰‰nt‰jien ohjelmointi matalan tason ohjelmointikielill‰ on eritt‰in vaivalloista~\cite[281]{Mogensen10},
suositaan niiden kehitt‰misess‰ korkean tason ohjelmointikielten k‰yttˆ‰.
Yksi vaihtoehto on ohjelmoida k‰‰nt‰j‰ jollakin kyseiselle laitteistolle
jo olemassa olevalla ohjelmointikielell‰. T‰m‰ ei kuitenkaan aina ole mahdollista.
Esimerkiksi, jos kyseess‰ on uusi prosessoriarkkitehtuuri, eik‰ t‰lle viel‰ ole k‰‰nt‰ji‰,
on ohjelmointi teht‰v‰ jollakin muulla tavalla.

K‰‰nt‰j‰, joka sek‰ k‰‰nt‰‰ ett‰ on suoritettavissa uudella laitteistolla voidaan
toteuttaa ketjutukseksi (bootstrapping) kutsutulla tekniikalla~\cite[281]{Mogensen10}.
Ketjutus on tekniikka, jonka ydinajatus on k‰‰nt‰‰ jokin k‰‰nt‰j‰ sill‰ itsell‰‰n~\cite[281]{Mogensen10}.
Tavanomaisen k‰‰nt‰j‰n sanotaan olevan ketjutettu jos se k‰‰nt‰‰ itsens‰~\cite[]{Appel94}.

\subsection{Iteratiivinen ketjutus}
%incremental bootstrap
Perinteinen ongelma k‰‰nt‰jien kehityksess‰ on tilanne, jossa k‰‰nt‰j‰ pit‰‰ ohjelmoida
ilman muita tyˆkaluja ja k‰‰nt‰ji‰. Iteratiivisessa ketjutusmenetelm‰ss‰
k‰‰nt‰j‰ kehitet‰‰n kahdessa osassa. Ensin k‰‰nt‰j‰st‰ tehd‰‰n
hyvin suppea versio, joka osaa k‰‰nt‰‰ tavoitellusta ohjelmointikielest‰ vain pienen
osajoukon~\cite[287]{Mogensen10}. T‰m‰ ensimm‰isen vaiheen k‰‰nt‰j‰ voidaan ohjelmoida
mill‰ tahansa ohjelmointikielell‰, mutta mik‰li muiden ohjelmointikielten k‰‰nt‰ji‰
ei ole saatavilla, se joudutaan tekem‰‰n konekielell‰. Toisessa osassa k‰‰nt‰j‰
ohjelmoidaan sen itsens‰ ymm‰rt‰m‰ll‰ kielell‰, eik‰ muita ohjelmointikieli‰ en‰‰ tarvita.
T‰llˆin jo olemassa oleva k‰‰nt‰j‰ voi k‰‰nt‰‰ seuraavan version itsest‰‰n. 
Koska kieli on t‰ss‰ vaiheessa viel‰ hyvin vajavainen, olisi valmiin ohjelmointikielen
toteuttaminen heti ensimm‰isen vaiheen j‰lkeen eritt‰in tyˆl‰st‰. Toista vaihetta 
suoritetaan useita kertoja siten, ett‰ k‰‰nt‰j‰n tuntemaa ohjelmointikielt‰ kasvatetaan
ja siit‰ k‰‰nnet‰‰n uusi k‰‰nt‰j‰. Saadun k‰‰nt‰j‰n avulla voidaan seuraava versio
toteuttaa k‰ytt‰en uusia ominaisuuksia. Seuraavan version avulla tehd‰‰n j‰lleen
seuraava versio, ja niin edelleen.
Huomioitavaa prosessissa on se, ett‰ k‰‰nt‰j‰n uusi versio on kehitett‰v‰ aina k‰ytt‰en 
vanhan version tuntemaa ohjelmointikielt‰. 

Kuva \ref{iterative-bootstrap} esitt‰‰ edell‰ kuvattua tilannetta. Ensimm‰isess‰ vaiheessa k‰‰nt‰j‰n ensimm‰inen
versio ohjelmoidaan konekielell‰ (ML, "Machine Language") ja t‰m‰n j‰lkeen ohjelmointikielt‰ (PL, "Programming Language") laajennetaan iteratiivisesti, kunnes tavoiteltu kieli on saavutettu.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{iterative-bootstrap-from-scratch.png}
		\caption{Iteratiivinen ketjutus ilman muita ohjelmointikieli‰. \label{iterative-bootstrap}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

Er‰s ongelma edell‰ kuvatussa prosessissa on kielen kehitykseen soveltuvan
sopivan osajoukon m‰‰ritteleminen~\cite[176]{Reynolds03}. Mik‰li ohjelmointikielt‰ laajennetaan vain
v‰h‰n, on p‰ivitys l‰hes hyˆdytˆn. Liian monimutkaisen kielen toteuttaminen
yksinkertaisella osajoukolla on puolestaan eritt‰in tyˆl‰st‰.

\subsection{Ketjutus olemassa olevien k‰‰nt‰jien avulla}
%half bootstrap TƒMƒ KOKO KAPPALE ON VƒHƒN HEIKOSTI KIRJOITETTU.
Ketjutusmenetelm‰‰ k‰ytet‰‰n usein myˆs yhdess‰ ristiink‰‰nt‰misen kanssa~\cite[175]{Reynolds03}.
T‰llˆin tavoitteena on siirt‰‰ jo olemassa oleva k‰‰nt‰j‰ toimimaan toisessa laitteistossa.
Oletetaan, ett‰ laitteistolle joka suorittaa konekielt‰ ML1 on toteutettu kielen PL k‰‰nt‰j‰.
Mik‰li kielen PL k‰‰nt‰j‰ halutaan toimimaan sek‰ tuottamaan uuden laitteiston konekielt‰ ML2, 
voidaan kielen PL k‰‰nt‰j‰ ohjelmoida uudelle laitteistolle ristiink‰‰nt‰mist‰ ja ketjuttamista k‰ytt‰en
seuraavalla tavalla. Ensin kielell‰ PL ohjelmoidaan sen itsens‰ k‰‰nt‰j‰ uudelle laitteistolle.
T‰m‰ voidaan k‰‰nt‰‰ alkuper‰isell‰ laitteistolla. Nyt kielelle PL on olemassa uudelle laitteistolle
koodia tuottava k‰‰nt‰j‰, mutta sen suoritus tapahtuu edelleen vanhassa laitteistossa (ristiink‰‰nt‰minen).
Nyt k‰‰nt‰j‰n uudella versiolla, jonka kohdekieli on ML2, k‰‰nnett‰ess‰ oma l‰hdekoodinsa
saadaan k‰‰nt‰j‰, joka sek‰ toimii ett‰ k‰‰nt‰‰ kielelle ML2.
Kuva \ref{cross-bootstrapping} havainnollistaa tilannetta. Ensimm‰isess‰ vaiheessa jo olemassa olevalla k‰‰nt‰j‰ll‰
k‰‰nnet‰‰n uuden k‰‰nt‰j‰n l‰hdekoodi, jolloin tulokseksi saadaan ristiink‰‰nt‰j‰.
Saadulla uudella k‰‰nt‰j‰ll‰ k‰‰nnet‰‰n sen oma l‰hdekoodi, jolloin tuloksena on haluttu
uudella laitteistolla toimiva ja sen konekielt‰ tuottava kielen PL k‰‰nt‰j‰.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{cross-bootstrap-T.png}
		\caption{K‰‰nt‰j‰n siirt‰minen uudelle laitteistolle ristiink‰‰nt‰misen ja ketjutuksen avulla. \label{cross-bootstrapping}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

%esimerkikksi ibm -> control data cite reynolds
%t‰ss‰ vois jo mainita intermediate languagen ja puhua front ja backendeist‰

%ir bootstrap
Edell‰ kuvattu esimerkki on toimiva, mutta se edellytt‰‰ k‰‰nt‰j‰n kirjoittamisen kokonaan
alusta loppuun asti sen omalla l‰hdekielell‰. Koska korkean tason ohjelmointikielten
k‰‰nt‰j‰t voivat olla todella monimutkaisia ja koostua suuresta m‰‰r‰st‰ l‰hdekoodia,
on t‰m‰nkaltainen prosessi varsin tyˆl‰s. Vastaavan prosessin voi toteuttaa huomattavasti
pienemm‰ll‰ vaivalla, mik‰li alkuper‰isen k‰‰nt‰j‰n rakenne olisi eri tavalla toteutettu.

%ibid
\subsection{Ketjuttamista helpottava k‰‰nt‰j‰rakenne}
Viel‰ 1970-luvulla k‰‰nt‰j‰t kirjoitettiin suurimmaksi osaksi yht‰ l‰hdekielt‰ ja laitteistoa varten~\cite[38]{Guilan02}.
1980-luvulla ruvettiin kehitt‰m‰‰n enenev‰ss‰ m‰‰rin k‰‰nt‰j‰kokonaisuuksia, jotka kykenev‰t 
k‰‰nt‰m‰‰n useita eri l‰hdekieli‰ (ibid). T‰llaisissa systeemeiss‰ k‰‰nt‰j‰n sis‰inen rakenne oli 
jaettu l‰hdekielest‰ riippuvaiseen etuosaan (frontend) sek‰ n‰iden jakamaan takaosaan (backend).
T‰m‰n kaltainen rakenne v‰hensi tarvetta kirjoittaa uutta koodia ja n‰in ollen pienensi k‰‰nt‰jien kehityksest‰
koituvia kustannuksia. 80-luvun lopulla oli jo hyv‰ksytty ajatus siit‰, ett‰ k‰‰nt‰jien
kehitys usealle ohjelmointikielelle ja/tai laitteistolle  on tehokkaampaa sek‰ kilpailukykyisemp‰‰ (ibid).

%t‰‰ nyt ei ihan oo usealle eri kielelle mutta ehk‰ usealle eri laitteistolle
Er‰s tyypillinen tapa k‰‰nt‰jien ohjelmoinnissa onkin jakaa sen sis‰ist‰ rakennetta sek‰
suorittaa k‰‰nnˆs useassa eri vaiheessa. Apuna k‰ytet‰‰n usein jotakin
v‰likielt‰~\cite[15]{Speetjens76}. N‰in haluttu l‰hdekieli voidaan k‰‰nt‰‰
helpommin eri laitteistoille.

%t‰‰ ois sit usealle eri laitteistolle.
Olettaen, ett‰ jollekin v‰likielelle IL ("Intermediate Language") ja jollekin korkean tason ohjelmointikielelle on
olemassa tietyll‰ laitteistolla toimivat k‰‰nt‰j‰t,
voidaan halutun l‰hdekielen k‰‰nnˆs suorittaa kaksivaiheisesti toteuttamalla
korkean tason ohjelmointikielell‰ k‰‰nt‰j‰ l‰hdekielelt‰ v‰likielelle~\cite[610]{Earley70}.
Uuden l‰hdekielen toteutus sis‰lt‰‰ siis vain korkean tason ohjelmointikielell‰ tehdyn
k‰‰nt‰j‰n k‰ytetylle v‰likielelle, eik‰ koodin generointivaihetta tarvitse kirjoittaa uudestaan.

%antaako t‰‰ kappalevaihdos nyt ymm‰rt‰‰ ett‰ kuva 7 olisi ylemm‰n tilanteen kaltainen?
Kuva \ref{compiler-complex} demonstroi usein k‰ytetty‰ rakennetta~\cite[610]{Earley70}, jolla k‰‰nt‰j‰n jatkokehityst‰ voidaan
helpottaa huomattavasti. 
Uuden ohjelmointikielen k‰‰nt‰j‰n toteuttaminen kyseisen k‰‰nt‰j‰n avulla on mahdollista
vain yhden komponentin (punainen) uudelleenohjelmoinnilla. Vaihtamalla toisen vaiheen 
ensimm‰inen k‰‰nt‰j‰ k‰‰nt‰m‰‰n uudelta l‰hdekielelt‰ (SL, "Source Language") v‰likielelle,
vaihtuvat myˆs seuraavissa komponenteissa olevat l‰hdekielet uuteen kieleen.
Uusi k‰‰nt‰j‰ tulee toteuttaa samalla ohjelmointikielell‰, jolla aiempi komponentti on
toteutettu (CWL, "Compiler Writing Language").
Esimerkiksi, jos kyseisell‰ j‰rjestelm‰ll‰ halutaan toteuttaa
konekielell‰ ML1 suoritettava C-k‰‰nt‰j‰, tulee ohjelmoida vain sellainen
osa, joka on kirjoitettu kielell‰ CWL ja k‰‰nt‰‰ C-kielt‰ v‰likielelle IL. Sama p‰tee
muihinkin toteutettaviin ohjelmointikieliin.

\begin{figure}[H]
	\ \newline
	\begin{center}
	    \hbox{\hspace{-0.6cm} \includegraphics[scale=1.0]{compiler-complex-color-T.png}}
	  \caption{K‰‰nt‰j‰kokonaisuus. \label{compiler-complex}}
	  \label{kuvaesimerkki}
	\end{center}
\end{figure}

Pelkk‰‰ v‰likielt‰ apuna k‰ytt‰en uuden ohjelmointikielen toteutus ei vaatisi n‰in
monimutkaista rakennetta. Kyseinen rakenne mahdollistaa kuitenkin sek‰ tehokkaan ristiink‰‰nt‰misen
ett‰ itsens‰ ketjuttamisen uudelle laitteistolle. Jos k‰‰nt‰j‰kokonaisuuden halutaan
k‰‰nt‰v‰n ymm‰rt‰m‰‰ns‰ l‰hdekielt‰ uudelle laitteistolle jonka, konekieli on ML2, joudutaan siihen
edelleen kirjoittamaan vain yksi uusi komponentti. T‰m‰ osa kirjoitetaan kielell‰ CWL ja
se k‰‰nt‰‰ v‰likielt‰ IL uuden laitteiston ymm‰rt‰m‰lle konekielelle ML2.  Kun kyseinen
osa k‰‰nnet‰‰n jo olemassa olevalla k‰‰nt‰j‰ll‰, saadaan tulokseksi
samassa laitteistossa toimiva k‰‰nt‰j‰ v‰likielelt‰ uudelle konekielelle.
Saadulla ristiink‰‰nt‰j‰ll‰ on siis mahdollista k‰‰nt‰‰ l‰hdekielt‰ SL
konekielelle ML2, mutta sen suoritus tapahtuu edelleen kielen alkuper‰ist‰
konekielt‰ ML1 ymm‰rt‰v‰ss‰ laitteistossa.

Ristiink‰‰nt‰misen mahdollistavan uuden osan avulla myˆs koko k‰‰nt‰j‰rakenteen
ketjuttaminen uuteen laitteistoon on mahdollista ilman lis‰ohjelmointia~\cite[610]{Earley70}.
Kuva \ref{bootstrap-complex} havainnollistaa t‰t‰ prosessia.
Ensimm‰isess‰ vaiheessa jo olemassaolevien
komponenttien sek‰ uuden CWL:ll‰ kirjoitetun v‰likielik‰‰nt‰j‰n (keltainen) avulla
tuotetaan seuraavissa vaiheissa tarvittavat komponentit.
N‰iden komponenttien avulla voidaan
toisessa vaiheessa tuottaa ML2-konekielell‰ toimiva ja siihen k‰‰nt‰v‰ v‰likielik‰‰nt‰j‰.
Kolmannessa vaiheessa tuotetaan ensimm‰isess‰ vaiheessa saadun v‰likielik‰‰nt‰j‰n
avulla ML2-kielell‰ toimiva CWL-k‰‰nt‰j‰, joka tuottaa v‰likielt‰.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{CWL-IL-bootstrap-complex-color-T.png}
		\caption{K‰‰n‰t‰kokonaisuuden ketjutus uudelle laitteistolle. \label{bootstrap-complex}}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

%laitetaan kuvaan ne vaiheet!!!!!!!
Sijoittamalla toisessa ja kolmannessa vaiheessa saadut k‰‰nt‰j‰t (sininen) alkuper‰iseen 
ohjelmistoon, saadaan sek‰ ML2-kielell‰ toimivat ett‰ sille k‰‰nt‰v‰t
komponentit. Ainoa komponentti, jota ei saada suoraan sijoittamalla, on ensimm‰isen vaiheen toinen komponentti.
Uudella konekielell‰ toimivat k‰‰nt‰j‰t CWL $ \rightarrow $ IL ja IL $ \rightarrow $ ML2 
vastaavat kuitenkin yhdess‰ t‰t‰ komponenttia.

K‰sitelty k‰‰nt‰j‰kokonaisuus on monimutkainen, mutta myˆs tehokas. Sek‰ uuden
l‰hdekielen toteutus alkuper‰isell‰ laitteistolla ett‰ koko k‰‰nt‰j‰ohjelmiston
siirt‰minen uuteen laitteistoon voidaan saavuttaa
vain pienen osan uudelleenohjelmoinnilla. Lis‰ksi uudelleenohjelmointi
voidaan suorittaa jo aiemmin k‰ytetyll‰ korkean tason ohjelmointikielell‰~\cite[610]{Earley70}.




\newpage
\section{Yhteenveto}


%k‰‰nt‰j‰n m‰‰ritelm‰, symbolinen konekieli
K‰‰nt‰j‰ll‰ tarkoitetaan tietokoneohjelmaa, joka k‰‰nt‰‰ l‰hdekielisen ohjelman
kohdekieliseksi ohjelmaksi. Jokaisella laitteistolla on oma konekielens‰, jota
se kykenee suorittamaan. Aluksi ohjelmointi oli mahdollista vain t‰ll‰
konekielell‰.
Koska konekielinen ohjelmointi oli tyˆl‰st‰ ja virhealtista, kehitettiin
avuksi symbolisia konekieli‰, joissa bin‰‰riset konek‰skyt oli korvattu
paremmin muistettavilla tekstuaalisilla symboleilla. Assemblyk‰‰nt‰j‰t
tuottivat symbolisista konekielist‰ yksinkertaisten s‰‰ntˆjen mukaan
laitteiston ymm‰rt‰m‰‰ konekielt‰.

%korkean tason ohjelmointikieli, syntyi vahingossa, historia lyhyt tiivistelm‰
Korkean tason ohjelmointikielet kehittyiv‰t ohjelmoijien tarpeesta kuvata
tietokoneiden toimintaa konekieli‰ korkeammalla abstraktiotasolla. Formaalien
kuvausj‰rjestelmien kehittyess‰
kokeiltiin myˆs konekielen tuottamista automaattisesti korkean
tason kielist‰. T‰m‰ automaattiseksi ohjelmoinniksi
ja myˆhemmin k‰‰nt‰miseksi kutsuttu prosessi oli alkuun melko tehotonta.
Moni tutkija pitikin sit‰ vain mielenkiintoisena tutkimuksena, mutta
potentiaali niiden tehokkaaseen k‰yttˆˆn selvisi varsin nopeasti.
Viimeist‰‰n FORTRAN:n julkaisun j‰lkeen
korkean tason ohjelmointikielten hyˆdyt oli laajasti hyv‰ksytty.

%v‰likielet
Ensimm‰iset k‰‰nt‰j‰t kehitettiin tietyn l‰hde- ja
kohdekieliparin k‰‰nt‰miseen. Kielten ja laitteistojen monipuolistuessa
tarvittavien k‰‰nt‰jien m‰‰r‰ lis‰‰ntyi. Syntyi ajatus universaalista
v‰likielest‰, jonka avulla tarvittavien k‰‰nt‰jien
%ristiink‰‰ntˆ
m‰‰r‰‰ voitaisiin pienent‰‰ ja ohjelmien ristiink‰‰nt‰minen uusille laitteistoille
nopeutuisi.
Vaikka mik‰‰n v‰likieli ei ikin‰ saanut universaalia asemaa,
k‰ytet‰‰n silti l‰hes kaikissa nykyaikaisissa k‰‰nt‰jiss‰ jotakin v‰likielt‰ k‰‰nnˆksen v‰livaiheena.
T‰llaiset k‰‰nt‰j‰t on jaettu etuosaan, joka k‰‰nt‰‰ l‰hdekielen v‰likielelle,
sek‰ takaosaan, joka k‰‰nt‰‰ v‰likielen halutulle laitteistolle.
%bootstrapping
V‰likieli‰ ja ristiink‰‰nt‰mist‰ k‰ytet‰‰n apuna myˆs ketjutuksessa.
T‰llˆin k‰‰nt‰j‰n ketjuttaminen uudelle laitteistolle onnistuu
mahdollisimman v‰h‰ll‰ uudelleenohjelmoinnilla.


%t kaaviot ???


\newpage

% Sitten alkaa l‰hdeluettelo
%\nocite{*}
\bibliographystyle{apalike}
\bibliography{lahteet}

\lastpage

\end{document}
