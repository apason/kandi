\documentclass[finnish]{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{float}

\usepackage[round]{natbib}
\setcitestyle{notesep={: }}

\begin{document}
\onehalfspacing
%lähdeluettelo oikeaan formaattiin
\makeatletter
\renewcommand\@biblabel[1]{[#1]}
\makeatother


\title{Historiakatsaus assemblykääntäjistä korkean tason kielten kääntäjiin}
\author{Arttu Kilpinen}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua}
\classification{\protect{\ \\
Software and its engineering -> software notations and tools -> Compilers}}

\keywords{Historia, Kääntäjät, Symbolinen konekieli, Ohjelmointikielet}

\begin{abstract}

  Ensimmäiset ohjelmointikielten kääntäjät, assemblykääntäjät, käänsivät symbolisille
  konekielille kirjoitettuja ohjelmia konekielisiksi ohjelmiksi. Täsmällisten
  kuvausjärjestelmien kehitys sekä koodin generoinnin teoria mahdollistivat
  tehokkaampien ohjelmointikielten kehityksen. Nykyisin käytössä olevat
  korkean tason ohjelmointikielet kehittyivät hiljalleen kuvausjärjestelmien
  kehittyessä ja syrjäyttivät symbolisella konekielillä ohjelmoinnin lähes
  kokonaan.
  Tässä dokumentissa käydään läpi historiallisia vaiheita symbolisten konekielten
  kääntäjistä nykyaikaisiin korkean tason ohjelmointikielten kääntäjiin. Läpi käydään
  useita merkittäviä ohjelmointikieliä ja niiden ominaisuuksia.
  
\end{abstract}

\mytableofcontents




\section{Johdanto}
Kääntäjät ovat tietokoneohjelmia, jotka kääntävät lähdekielisen ohjelmakoodin
kohdekieliseksi ohjelmaksi~\citep[1]{Bauer74}. Kohdekielenä on usein jonkin prosessoriarkkitehtuurin
ymmärtämä konekieli.

%
Ohjelmointikielet sekä niitä ymmärtävät kääntäjät ja tulkit ovat keskeisessä asemassa
ohjelmistotuotannossa. Kääntäjät mahdollistavat ohjelmien
kirjoittamisen korkean tason ohjelmointikielillä sekä symbolisilla konekielillä,
jotka puolestaan helpottavat ja nopeuttavat ohjelmointia.
Niiden käyttäminen tekee ohjelmakoodista myös ymmärrettävämpää ja
helpompilukuista. Yleisesti ottaen ohjelmointikielen ymmärrettävyys kasvaa abstraktiotason
kasvaessa. Esimerkiksi matemaattisesti tutulla tavalla kirjoitetut aritmeettiset lausekkeet
ovat ymmärrettävämpiä kuin vastaava laskenta symbolisella konekielellä ohjelmoituna.
Lisäksi useat korkean tason ohjelmointikielet mahdollistavat --- mikäli
tarvittavat kääntäjät ovat olemassa --- saman ohjelmakoodin käyttämisen useissa eri
laitteistoissa sekä useilla eri käyttöjärjestelmillä. Koska eri laitteistoissa
on erilaiset käskykannat, poistuu korkean tason ohjelmointikieliä käyttämällä
myös tarve uudelleenohjelmoinnille. 

%
% Jotain introa myös historiasta. Johdannon pitäisi kuitenkin johdattaa tekstiin joka on
% pääasiassa historiapainotteista. 
%

Symboliset konekielet sekä korkean tason ohjelmointikielet ovat lähes yhtä vanhoja kuin
ohjelmointikin. Ensimmäiset korkean tason ohjelmointikielten kääntäjät puolestaan ovat
ohjelmointikieliä huomattavasti nuorempia, sillä ohjelmointikielten teoriaa kehitettiin
vuosia ennen kuin ensimmäiset kääntäjät valmistuivat. Esimerkiksi ensimmäisenä korkean
tason ohjelmointikielenä pidetty Plankalkül kehitettiin jo vuonna 1945, mutta sitä
ymmärtävä kääntäjä valmistui vasta vuonna 1972~\cite[????]{Knuth76}. %EI LÖYDY??? 
%vois laittaa et "yritettiin valmistaa" tms.

Ennen korkeatasoisille lausekielille kehitettyjä
kääntäjiä oli pitkään käytössä vain symbolisia konekieliä ymmärtäviä ohjelmia, % pitkään?
assemblykääntäjiä. Korkean tason ohjelmointikielten kehityttyä saatiin myös niitä
tukevia kääntäjiä valmistettua. Vuonna 1952 valmistunut AUTOCODEn kääntäjä oli
yksi ensimmäisiä kaupallisessa ohjelmistotuotannossa käytettyjä korkean tason kielen
kääntäjiä~\cite[42]{Knuth76}. % vähän irrallaan tää autocode tässä..

\newpage

%vaatii muutosta start
%Vaikka kääntäjien tuottama kohdekieli on usein laitteiston ymmärtämää konekieltä
%tai symbolista konekieltä, on myös olemassa kääntäjiä, jotka tuottavat jotakin
%korkean taso lausekieltä. 

% Tähän myös jotain introa käännöstekniikoista cross, bootstrap, parsereista jne
% pitäis saada puoltoista sivua tekstiä


%tää koko kappale on ihan vitun perseestä :::::D
\section{Symbolinen konekieli ja assemblykääntäjät}
Erään määritelmän mukaan assemblykääntäjä on kääntäjä, joka kääntää yksi yhteen
symbolisella konekielellä kirjoitettuja komentoja konekielisiksi komennoiksi~\cite[1]{Salomon93}.
%
Koska jokaisella laitteistolla on oma konekielensä ja tämä konekieli on myös ohjelmointikieli,
pätee yleinen kääntäjien määritelmä myös assemblykääntäjiin. Lähdekielenä assemblykääntäjän
ymmärtämä symbolinen konekieli tarkoittaa konekieltä, jossa laitteen ymmärtämät binääriset konekäskyt
on korvattu ihmisille helpommin muistettavilla sanoilla eli symboleilla.
%http://www.dcs.warwick.ac.uk/~edsac/Software/EdsacTG.pdf edsac instruction set



%Aika ennen symbolisia konekieliä. Mainitaan babbagen vehkeet
%Kerrotaan raudasta HYVIN yksinkertaisesti EDSAC z4




\subsection{Historia ensimmäisistä assemblykääntäjistä}
%Ensimmäiset ohjelmointia helpottavat ohjelmat olivat assemblerkääntäjiä.

Koska ennen ensimmäisiä assemblykääntäjiä ei ollut mitään ohjelmointia
helpottavia työkaluja, tuli ensimmäiset kääntäjät ohjelmoida suoraan konekielellä.
Esimerkiksi yksi ensimmäisistä assemblykääntäjistä, vuonna 1949 valmistunut EDSAC-tietokoneen
assemblykääntäjä toteutettiin tällä tavalla. % VIITE
kuten yksi ensimmäisiä, vuonna 1949 valmistunut EDSAC tietokoneen assemblykääntäjä
toteutettiin. Vaikka korkean tason kielten kääntäjät alkoivat kehittyä
lähes heti ensimmäisten assemblykääntäjien valmistuttua, pysyi symbolisilla
konekielillä ohjelmointi pitkään suosiossa. Alkuun korkean tason kielten
automaattista käännöstyötä pidettiin lähinnä teoreettisena tutkimisena
%VITTU EIHÄN TÄÄ KUULU TÄHÄNN KAPPALEESEEN!!!
ja käytännössä kaikki ohjelmoijat uskoivat ettei automaattisesta koodin generoinnista
tule ikinä tarpeeksi tehokasta oikeaan ohjelmointiin~\cite[61]{Knuth76}.


Vaikka nykyaikaiset korkean tason ohjelmointikielien kääntäjät tuottavat
hyvin optimoitua koodia, on hyvän ohjelmoijan kirjoittama symbolinen
konekieli silti lähes poikkeuksetta parempaa. Tämän takia symbolisia %LÄHDE PYYDETTY aiempi lause, MUTTA TYÖLÄÄMPÄÄ
konekieliä käytetään jonkin verran matalan tason ohjelmoinnin lisäksi
suurta laskentatehoa vaativien ohjelmien optimointiin.
%
Ennen symbolisten konekielten kehitystä ohjelmointi tapahtui kirjoittamalla
laitteistoriippuvaista tietyn prosessorin ymmärtämää binäärikoodia. Siitä huolimatta,
että käskykannat olivat nykyiseen verrattuna suhteellisen yksinkertaisia, 
oli ohjelmointi hidasta ja työlästä. Tietokoneiden kehittyessä ja ohjelmien
monimutkaistuessa tarve ohjelmointikielille kasvoi. Symboliset konekielet
kehitettiin varhain ja nykyisin lähes kaikki sovellusohjelmat kirjoitetaan
korkean tason ohjelmointikielillä.
% Missä?
% Milloin?

\subsection{Assemblykääntäjien toiminnasta ja toteutuksesta}
%Tämä tekee matalan tason ohjelmointikielistä eli (symbolisista) konekielistä täysin laitteistoriippuvaisia.
Assemblykääntäjät ymmärtävät jotakin symbolista konekieltä ja osaavat
tuottaa tästä konekielisen suoritettavan ohjelman.
Symboliset konekielet ovat matalan tason laiteriippuvaisia ohjelmointikieliä,
jotka kääntävät lähdekoodia yksinkertaisin ennalta määrätyin ehdoin kohdekielelle.
Suurin osa ohjelmakoodista on siis käännettävissä yksi yhteen laitteiston
ymmärtämän konekielen kanssa. Poikkeuksena on kuitenkin ohjelman osoitteina
käytettävät tunnukset (label), joiden arvot assemblykääntäjä voi
vapaasti päättää. Tunnuksina ovat joko paikat ohjelman koodiosassa
tai muuttujina käytetyt muistipaikat. Symbolisen konekielen avainsanat
ovat siis symboleja laitteiston ymmärtämälle konekielelle. Konekielellä on
mahdollista kirjoittaa suoraan suorittimen rekistereihin. Tämä tekee symbolisilla konekielillä ohjelmoimisesta
yhtä laiteläheistä kuin suoraan konekielillä ohjelmointikin. Laiteläheisyys
puolestaan tekee ohjelmista laitteistoriippuvaisia, sillä eri suorittimilla
voi olla erilaiset käskykannat. Symbolien käyttäminen vähentää huomattavasti
kirjoitusvirheiden määrää ja tekee koodista helpomman kirjoittaa ja lukea.
Tunnisteiden käyttö puolestaan poistaa tarpeen muistaa muuttujien sekä
konekäskyjen osoitteita.
%vois sanoa että symbolinen konekieli on siis sama asia kuin konekieli, mutta symbolein kirjoitettuna.

% Miten?

%jotain direktiiveistä
% labeleista. Ei täysin yksi yhteen! KUVA! 


Kuva 1 selventää symbolisten konekielten määtittelemien symbolien
sekä ohjelmoijan määrittelemien tunnisteiden eron. Esimerkkikoodi on TTK91 ~\cite[]{Ttk91}
virtuaaliprosessorille tehty ohjelma, joka tulostaa käyttäjälle luvut
0...5. Keltaisella pohjalla olevat symbolit ovat niin sanottuja tunnisteita,
joilla voi olla eri arvo käännöskerrasta ja kääntäjästä riippuen.
Kaikki harmaalla pohjalla oleva koodi käännetään siis täysin ennalta määrätysti.


\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{esimerkkiTTK.png}
\caption{TTK91 esimerkkikoodi}
\label{kuvaesimerkki}
\end{center}
\end{figure}

\newpage
\section{Historiaa korkean tason kielten kääntäjistä}

Korkean tason ohjelmointikielellä tarkoiteteen tässä dokumentissa ohjelmointikieltä,
jossa lähdekielikieli sekä siitä käännettävä konekieli ovat  % nyt vittu poissuljetaan ne kääntäjät jotka ei käännä assyks tai binääriks!
selkeästi eri abstraktiotasoilla ja kääntäminen edellyttää muutakin, kuin mekaanista
sanojen vaihtamista ennalta määrättyjen sääntöjen perusteella. Tämän määritelmän
perusteella korkean tason ohjelmointikielillä tarkoitetaan tässä dokumentissa niitä kieliä,
jotka eivät ole symbolisia konekieliä.

% Kerrotaan korkean tason kielten hyödyistä ja miksi niitä tarvitsee
\subsection{Täsmällisten kuvausjärjestelmien kehitys}

Tietojenkäsittelytieteilijät ovat jo tietokoneiden alkuajoista lähtien
yrittäneet kuvailla ohjelmien suoritusta ja algoritmeja konekieltä
abstraktimmalla tasolla. Alan Turingin julkaisussa vuonna 1936 esitettiin
määritelmä tietojenkäsittelijöiden hyvin tuntemasta laskentalaitteesta,
Turingin koneesta. Laitteen yhteydessä määriteltiin
% HMM? eikö laite itse ole jo määritelmä esitystavasta?
myös matemaattinen esitystapa, jolla sen toimintaa voitiin täsmällisesti %LÄHTEET turing oma!
kuvailla. Vaikka esitystapa oli vaikea eikä kyseisiä Turingin
esittelemää laitetta ollut kuin teoriassa, %huonosti sanottu TEORIASSA
Turingin esitystapa edusti kehittyneintä formaalia
kuvausta, 'kieltä', joka siihen aikaan oli olemassa. %millon tuli lambda?

Toisen maailmansodan jälkeen vuonna 1945 saksalainen Konrad Zuse aloitti %LÄHTEET PYYDETTY mul on paperilla!
oman tietokoneohjelmien kuvailuun tarkoitetun kielen Plankalkülin kehittämisen.
Zusen sanoin Plankalkülin tarkoitus oli luoda puhtaasti formaali esitystapa
mille tahansa laskentaongelmalle ~\cite[10]{Knuth76}. Tässä hän onnistuikin varsin hyvin.
Plankalkulissa voidaan määritellä aritmetiikan ja ohjausrakenteiden lisäksi
rajaton määrä sisäkkäisiä tietorakenteita ja Zusen työhön viitataankin
usein ensimmäisenä korkean tason ohjelmointikielenä.
%
Vaikka kyseessä oli huomattavan edistyksellinen järjestelmä, se ei
kuitenkaan vaikuttanut ohjelmointikielten kehitykseen juuri lainkaan.
Zusen artikkelit julkaistiin vasta vuonna 1972 muiden, kehittyneempien
kielten jo olemassa ollessa. Vaikka Plankalkülille toteutettiinkin
kääntäjä, ei sitä juuri koskaan käytetty koska silloin oli jo Plankalkülia
huomattavasti kehittyneempiä ohjelmointikieliä. %err? oliks sitä kääntäjää nyt vai ei??

%% -''thus  the plankalkul arose purely as a piece of desk-work..''
%% -45 alkoi plankalkulin kehitys. extension of Hilbert's Aussagenkalkul (propositional calculus) and prädikatenkalkul
%% (propositional calculus)
%% -zusen käsuikirjoitus julkaistiin asta 1972,
%% -k-äsikirjoitus alkaa 'The mission of the plancalculus is to provide a purely formal description of any
%% computational procedure' -> Ajatuksena ei varsinaisesti ollut kieli vaan notaatio ohjelmille, Ei suunnitellut kääntäjää.
%% -plankalkul included the important concept of hierarchically structured data going all the way dowen to the bit level. suck
%% advanced data structures did not enter again int o programming languages until the late 1950 in imbss commercial translator.
%% %zu45    - zuse marked that the number of possible data types was so large ti would be impiossible to indicate a variables
%% % type simply by using typographical conventions


Samoihin aikoihin Zusen kanssa Yhdysvaltalaiset Herman Goldstine ja
John von Neumann koittivat ratkaista samaa ongelmaa. Heidän ratkaisunsa
algoritmien ja tietokoneohjelmien kuvaamiseen oli varsin erilainen.
Von Neumann ja Goldstine esittivät ratkaisuksi lohkokaaviota (flow diagram),
esitystapaa jossa ohjelmat kuvataan nuolien ja laatikoiden avulla. %LÄÄHTEEEEEEET

% VAATII HIOMISTA START

%CU50', CU48, CU50 %VITTU KOKO TÄÄ CURRY ON WIKLAN MIELEST PASKAA PISTETÄÄ UUSIKS
Vuonna 1946 Marylandissa työskennellyt Haskell B. Curry kehitti ENIAC
tietokoneelle aikaansa nähden monimutkaista ohjelmaa. Curryn työ ENIACIN
parissa sai hänet ehdottamaan formalismia ohjelmistojen toiminnalle.
Hänen formalisminsa perustui uuteen ajatukseen ohjelman suorituksen
lohkomaisesta rakenteesta, mitä hän nimitti divisiooniksi. %CU50
Divisioonien tulisi olla rakennettu niin että niiden laskenta olisi
toisistaan riippumatonta. Tämän voisikin rinnastaa esimerkiksi
C-kielen paikallisiin tietorakenteisiin ja käännösyksiköihin perustuvaan
suoritukseen. Curryn formalismi oli kuitenkin hieman luonnoton %knuth74
sillä suoritusyksiköillä oli useita lopetuskohtia sekä nykykielistä poiketen
useita aloituskohtia.
%
Historiallisesti työ oli kuitenkin merkittävä, sillä se sisälsi algoritmeja
joilla kuvauksesta pystyttiin tuottamaan konekoodia. Näitä rekursiivisia
--- vaikkakin toteuttamatta jääneitä --- algoritmeja voidaankin pitää ensimmäisinä
koodin generointiin tarkoitettuina algoritmeina.

%% -haskel curryn monimutkaienn työ eniacin kanssa sai hänet esittämään notation for program construction that is more
%% compact than flowcharts.
%% -actually the main feature of interest in currys earlier work is not this programming language but rather the algorithms
%% hediscussed for converting parts of it into machine language. he gave a recursive description of a procedure to convert
%% faifly general arithmetic
%% expression into code for a one address compuiter thereby being the first person to describe the code generation phase of a compiler.
%% syntaksin tarkastusta ei kuitenkaan ollut vaan kääntäjä? oletti sen olevan ok.
% END





\subsection{Kohti ensimmäisiä kääntäjiä}

Millekään aiemmin mainituista ohjelmointikielistä ei tähän mennessä oltu
toteutettu kääntäjiä. Ne toimivat ohjelmoijien käsitteellisenä apuna auttaen
ohjelmien suunnittelussa, mutta jättäen toteutuksen ihmisille. Tästä huolimatta
ne kaikki olivat merkittäviä askeleita kohti parempia ohjelmointikieliä sekä
niiden kääntäjiä. Ilman täsmällisiä esitystapoja ei koodin generointi ikinä
olisi tullut mahdolliseksi.



% MAUCHLY 
Ensimmäinen korkean tason ohjelmointikieli, jolle toteutettiin tulkki oli Short Code.
Sitä kehitti John W. Mauchly vuonna 1949 ja William F. Schmitt toteutti sille tulkin ~\cite[23]{Knuth76}.
Tulkki toimi alkuun BINAC tietokoneella mutta se ohjelmoitiin myöhemmin myös UNIVACille.
Yksityiskohtia Short Coden toiminnasta ei ikinä julkaistu, joten sen tarkemmasta
toiminnasta ei ole tietoa. Vuonna 1955 julkaistusta ohjelmoijille tarkoitetussa
manuaalissa kerrotaan kuitenkin kuinka ohjelmaa voidaan käyttää. % RR55
Short Code oli siis algebrallinen tulkki, joka osasi suorittaa aritmeettisia %mikä vittu on algebrallinen tulkki t. wikla
laskutoimituksia ilman konekielistä ohjelmointia. Ohjelma luki syötettä ja
suoritti vastaavat toiminnot ajetulla laitteistolla.

% RUTISHAUER & BÖHM


1950-luvun alussa Heiniz Rutishauser ja Corrado Böhm työskentelivät Zürichin %onko kirjoitusasu ok?
teknillisessä yliopistossa Sveitsissä. Vaikka he työskentelivät samassa paikassa
ja saman aiheen parissa, eivät he työskennelleet yhdessä. Rutishauser julkaisi
1952 artikkelin, jossa hän kuvasi hypoteettisen tietokoneen sekä siinä toimivan
kääntäjän kehittämälleen ohjelmointikielelle. Julkaisu oli merkittävä, sillä
siinä kuvattiin ensimmäistä kertaa menetelmä kääntäjien toteuttamisesta %LÄHTEET t. wikla
sekä koodin generoinnista. % mitä eroa curryn algoritmeihin nähden?? RU52


Rutishauserin kollega Corrado Böhm kehitti myös ohjelmointikieltä sekä
tämän kääntäjää. Hänen julkaisunsa oli Rutishauserin julkaisua vieläkin
merkittävämpi, sillä hän oli toteuttanut kääntäjän tämän omalla kielellä.
Böhmin kieli ei kuitenkaan osannut käsitellä muita kuin positiivisia
kokonaislukuja, joten sen käyttöarvo jäi melko pieneksi. Kääntäjien
teorian kehityksen kannalta se oli kuitenkin korvaamaton. Böhmin kääntäjä %LÄHTEET
kykeni tarkistamaan koodin syntaksia lineaarisessa ajassa kun Rutishauserin
kääntäjä toimi suuruusluokassa $n^2$. Lisäksi Böhmin kääntäjä hallitsi matemaattisten
operaattoreiden sidontajärjestyksen, sekä osasi käsitellä sulkeita aritmeettisissa %LÄHTEET
lausekkeissa. Lisäksi Böhm oli ensimmäinen tietojenkäsittelijä, joka todisti % oliko ensimmäinen vai ensimmäinen tässä dokumentissa?
matemaattisesti ohjelmointikielensä voivan laskea minkä tahansa laskettavan funktion. %BO52 universaali. parempi sana??
%rutishauser and böhm had had a considerable advantage over glennie in that they had designed theri own machine code


% VITTU MITÄ PASKAA START
Vaikka Rutishauser ja Böhm olivat kumpikin valmistaneet %vittu oliko??
omat kääntäjänsä, pidetään ensimmäisenä 'oikeana' kääntäjänä silti
Alick E. Glennien 1952 valmistamaa AUTOCODE ohjelmistoa. Aiemmista kääntäjistä poiketen
AUTOCODE toteutettiin oikealle laitteistolla ja sen tuottama konekieli
oli oikeasti suoritettavissa. AUTOCODEa pystyttiin siis käyttämään oikeiden,
käyttökelpoisten ohjelmien tekemiseen ~\cite[42]{Knuth76}.

%% --- vaikka olikin kokeneille ohjelmoijille tarkoitettu ~\cite[Knuth74]
%% --- käytettiin, kuten tarkoitus oli, oikeaan ohjelmointiin.

%VITTU MITÄ PASKAA END

%Murray käytti ensimmäisenä sanaa compiler

% EHKÄ NÄMÄ VIELÄ OMIKSI LUVUIKSEEN

%maininta IBM!
Vuoden 1954 alussa John Backus rupesi kehittämään kokoamansa kehittäjätiimin kanssa
automaattisen ohjelmoinnin järjestelmää. Järjestelmän oli tarkoitus olla hyvin
kehittynyt, joten suureksi haasteeksi muodostui järjestelmän saaminen tarpeeksi
tehokkaaksi. Loppuvuodesta 1954 kehittäjäryhmä julkaisi suunnitelman järjestelmästä 'The IBM 
Mathematical FORmula TRANstating system' --- FORTRAN. Kuten jo aiemmin oli todettu, %LÄHTEET t. wikla
tehokkaan koodin tuottaminen ei ollut lainkaan helppoa. Ryhmän julkaisu alkoikin
painottamalla sitä tosiasiaa, että FORTRAN oli tehokas. Aiemmin ohjelmoijien tuli
valita helpon ohjelmoinnin ja hitaan suorituksen tai työlään ohjelmoinnin ja nopean
suorituksen väliltä, mutta FORTRANin tarjoaisi parhaat puolet molemmista ~\cite[1]{IBM54}. %IB54 EN OO VIEL LUKENU MUT MENKÖÖ
FORTRAN 0 dokumentti esittää myös ensimmäisen yrityksen esittää ohjelmointikielen
syntaksi täsmällisesti. Tätä voidaan pitää Backuksen myöhemmin esittelemän kielioppimuodon
Backus Naur Formin (BNF) edeltäjänä.
%ei oltu vielä implementoitu. Työhen meni 2.5 vuotta!!!

Kun FORTRAN kaksi ja puoli vuotta myöhemmin saatiin toteutettua, oli se
aikansa tehokkain sekä monipuolisin ohjelmointikieli. FORTRAN tuotti
kohtuullisen tehokasta koodia ja kehittäjät sanoivat sen olevan lähes
yhtä tehokasta kuin hyvän ohjelmoijan kirjoittama symbolinen konekieli.
FORTRANissa oli myös paljon ominaisuuksia, joita ei oltu aiemmin nähty.
Se oli esimerkiksi ensimmäinen ohjelmointikieli, jossa muuttujien nimet
voivat olla useamman merkin pituisia ~\cite[62]{Knuth76}. %entä ass kielten tunnukset t. wikla

Ensimmäisen julkaisun jälkeen FORTRANissa oli kuitenkin useita ognelmia.
Virheitä oli paljon ja eräs FORTRANIN kehittäjistä, Saul Rosen, %OLIKO SAUL ROSEN kehittäjä!?
%OLIKO bugeja edes paljon vai viitattiinko tossa aikaan ennen julkaisua perkele?!
sanoikin ettei uskonut FORTRANin ikinä tulevan toimimaan~\cite[4????]{Rosen64}.
Vaikeuksista huolimatta FORTRANista tuli hyvin suosittu ja sitä käytetiin
enemmän kuin oltiin osattu odottaa.

Taulukko 1 tiivistää aiemmissa kappaleissa esiteltyjen ohjelmointikielten merkittävimmät
piirteet. Lisäksi taulukossa esitellään ohjelmointikielten nimet sekä päätekijät.

\begin{table}[h!]
  \centering
  \caption{Yhteenveto ohjelmointikielten ja kuvausjärjestelmien kehityksestä}
  \label{tab:table1}
  \begin{tabular}{| l | l | l |}
    \hline
    \textbf K\textbf i\textbf e\textbf l\textbf i & \textbf K\textbf e\textbf h\textbf i\textbf t\textbf t\textbf ä\textbf j\textbf ä\textbf  & \textbf E\textbf n\textbf s\textbf i\textbf m\textbf m\textbf ä\textbf i\textbf n\textbf e\textbf n \\ \hline
    Plankalkül & Zuse & Ohjelmointikieli, Hierarkkinen data \\ \hline
    Virtauskaaviot & Goldstine, & Hyväksytty ohjelmointimetodologia \\
     & Von Neumann &  \\ \hline
    Short Code & Mauchly & Toteutettu korkean tason ohjelmointikieli \\ \hline
    Formules & Böhm & Samalla kielellä kirjoitettu kääntäjä \\ \hline
    AUTOCODE & Glennie & Käyttökelpoinen kääntäjä \\ \hline %LÄHDE? löytyy kurssisivulta mulle suositelluista lähteistä
    FORTRAN I & Backus & I/O formaatti, kommentit, globaali optimointi \\ \hline
  \end{tabular}
\end{table}

%% Almost to a ma nthey firmly believed that any mechanical coding method would fail to apply that versatile ...
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -57
%% -paljon tuntemattomia projekteja sillä olivat niin edistyksellisiä ettei tutkimustuloksia ikinä julkaistu.

%% -Alick glennie AUTOCODE 1952
%% -yleisesti pidetään ensimmäisenä ``oikeana'' ``kunnon'' kääntäjänä.-
%% - glennie sanoin 1953: to  make it easy one must make coding  comprehensible. this may be done only by improving the
%% notation of programming., aikaisemmat notaatiot ovat ongelmallisia.
%% ä- autocode was still very machine oriented.
%% - autocode oli tärkeä askel eteenpäin  vaikka olikin machine oriented ja tarkoitettu kokeneille ohjelmoijille

%% TÄHÄN MENNESSÄ kukaan ei ollut käyttänyt vielä termiä kääntäjä. terminä oli automaattinen koodausw (automatic coding)
%% sitten sitä käytettiin


%% -1954 John Backus työskenteli ibm tehdäkseen paremman systeemin automaattisesta ohjelmoinnista BA 76
%% -suuri ongelma oli tehokkuus. Lähes kaikki alalla uskoivat että any mechanical coding method would fail apply that
%% versatile ingenuity which each programmer felt he possessed and vonstantly neededi nhis gwork.
%% it was agreed compilers could only turn out code which would be intolerably less efficient than human coding.

%% -by november 1954 bakusin ryhmä oli speksannu the ibm mathematical formula translating system FORTRAN.

%% ensimmäinen paragrafi IB 54 tähdensi että aiemmat systeemit olivat tarjonneet vaihtoehdoiksi helpon ohjelmoinnin ja
%% hitaan suorituksen tai työlään ohjelmoinnin ja nopean suorituksen. mutta fortranilla molemmat olivat mahdollisia.

%% fortran oli enswimmäinen kieli missä muuttujalla voi olla useamman merkin nimi.

%% -fortran 0 dokumentti esitteli ensimmäisen yrityksen määritellä ohjelmointikielen syntaksi täsmällisesti. bakusin tärkeä huomio
%% BA 95 mistä tuli BNF voidaan nähdä tulevan täältä.



%% -assemblyien suosio pysyi esim koska esim x kääntäjän optimointi oli paska. vain 50% tehokas

% ensimmäinen kääntäjä vasta 1975 Joachim Hohmann: Der Plankalkul im Vergleich mit algorithmischen Sprachen. Reihe Informatik und Operations Research, S. Toeche-Mittler Verlag, Darmstadt 1979, ISBN 3-87820-028-5161.
% ensimmäinen 'useful' 'real' compiler, knuth 77 - sivu 42.
%% \section{tekniikkaa}
%% \subsection{bootstrapping}
%% \subsection{cross compiling}
















%% However one could discuss how an existing compiler could propagate an image of itself to another machine.
%% This technique popularly referred to as bootstrapping or cross compiling ~\cite{Reynolds03}.

%% A conventional C compiler, written in C, is said to be bootstrapped if it compiles itself.
%% Now suppose a new version of the compiler source is weirren, that uses different registers for passing arguments.
%% The old compiler can compile this source, yelding a new compiler. But Look! The executable version cc'
%% of the new compiler uses the old parameter passing style, but generates code that uses the new style.
%% onecan use the new compiler however to recompile all the libraries and the new version itself
%% and get a new new executable thet both uses and generates the new parameter passing style ~\cite{Appel94}.


%% -intermediate language as a tool to reduce duplivaton of effort.
%% -tämän takia cross compilation saanut paljon huomiota.
%% -cc on prosessi of one machine accepting a source program as input and producing an object code thet is executable on another machine.
%% -ongelma kääntäjien määrien kanssa, siksi IL.
%% -Saanut alkunsa UNCOLsta
%% ~\cite{Speetjens76}.

\section{Välikielet ja ristiinkääntäminen}
Jo 1950-luvun lopulla sekä käytettävissä olevien ohjelmointikielten että erillaisten laitteistojen
määrä oli kasvanut merkittävästi. Korkean tason ohjelmointikielillä
ohjelmoinnista oli tullut yleistä ja sen hyödyt olivat laajalti tunnettu ~\cite[12]{Strong58}.
Uusien laitteistojen kehitys oli nopeaa ja tyypillisesti laitteistoja uusittiin
viimeistään viiden vuoden välein (ibid). Vaikka korkean tason ohjelmointikielten
käyttö vähensi tarvetta sovellusten uudelleenohjelmoinnille, muodostui kääntäjien
kehitys merkittäväksi ongelmaksi. Tehokkaan kääntäjän kehittämiseen kuluva
aika oli samaa suuruusluokkaa laitteistojen käyttöiän kanssa,
joten hyvien kääntäjien valmistuttua oli laitteisto jo vanhentunut (ibid).
Onglmaa koitettiin välttää erilaisilla käännöstekniikoilla. Yleiseksi tavaksi
muodostui ristiinkääntäminen uusille laitteistoille.

%laitetaanko tähän väliotsikko vai ei?
\subsection{Ristiinkääntäminen}
%https://www.gnu.org/savannah-checkouts/gnu/automake/manual/html_node/Cross_002dCompilation.html
Tavallisesti tietokonejärjestelmissä käytettävät kääntäjät tuottavat konekieltä samalle
laitteistolle, jossa niitä ajetaa. Ristiinkääntämisellä (cross compiling) tarkoitetaan
sitä että, kohdelaitteisto on jokin muu, kuin käännöstä suorittava laitteisto ~\cite[]{GNU16}.
Ristiinkääntämisen mahdollistamiseksi tehdään, vanhalla laitteistolla jo olemassa olevia
ohjelmointikieliä käyttäen kääntäjiä, jotka tuottavat ohjelmia uusille tietokoneille.
Saaduilla ristiinkääntäjillä pystytään ohjelmoimaan kääntäjiä jotka toimivat uudessa laitteistossa.

%miten toi pilkku nyt menee?
Ongelmana edellä mainitussa menetelmässä on suuri, jatkuvasti kasvava joukko sekä lähde- että
kohdekieliä. Jo yhden uuden kääntäjän toteuttaminen on varsin työlästä joten uuden kääntäjän
tekeminen kaikille halutuille laitteistoille vaatisi massiivisesti aikaa ja resursseja.
Oletetaan että korkean tason ohjelmointikielten määrä on N ja laitteistojen määrä on M.
Tällöin tarvittavien kääntäjien määrä on NxM ja se kasvaa neliöllisesti kohde- tai lähdekielien
kasvaessa. Kuva X esittää tilannetta jossa on kääntäjät kuudelle eri ohjelmointikielelle
viiteen eri laitteistoon. 
%loppuuko tää kappale vähän tönkösti?

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{NxM.png}
		\caption{Ristiinkääntäminen usealta lähdekieleltä usealle kohdekielelle. Lähde: ~\cite[378]{Steel61}.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure} 

\subsection{Välikielet}
Mikäli olisi olemassa sellainen ohjelmointikieli, jolle olisi toteutettu kääntäjä kaikille
mahdollisille laitteistoille, voitaisiin korkean tason ohjelmointikielet kääntää
mille tahansa laitteistolle tätä kieltä apuna käyttäen. Tälläisellä menetelmällä
tarvittavien kääntäjien määrä vähenisi huomattavasti. Uudet ohjelmointikielet saataisiin
toimimaan millä tahansa laitteistolla vain yhen uuden kääntäjän avulla. Uuden ohjelmointikielen
kääntäjä kääntäisi sitä kyseiselle välikielelle, josta se voitaisiin jo olemassa olevien
kääntäjien avulla kääntää mille tahansa laitteistolle.

Idea tunnettiin alunperin nimellä UNCOL (UNiversal Compuiter Oriented Language) ~\cite[14]{Strong58}.
UNCOL ei ollut mikään suunniteltu ohjelmointikieli, vaan pikemminkin idea välikielestä,
jonka avulla kääntäjiä voisi toteuttaa pienemmällä vaivalla. Siitä puhuttiin jo vuonna
1954, eikä konseptin alkuperäistä keksijää tunneta (ibid).

Mikäli jonkinlainen UNCOL --- kaikkien kääntäjien tuntema välikieli --- olisi olemassa,
vähenisi ristiinkääntämiseen tarvittavien kääntäjien määrä huomattavasti. Jos
ohjelmointikielten määrä on N ja laitteistojen määrä M, tarvittaisiin tällaisessa
välikieliratkaisussa vain N+M uutta kääntäjää ~\cite[15]{Speetjens76}. Toisin sanoen kääntäjien määrä kasvaisi
lineaarisesti ohjelmointikielten ja laitteistojen suhteen. Kuvassa X esitetään
tilanne välikielen avulla. 

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{N+M.png}
		\caption{Ristiinkääntäminen välikielillä. Lähde: ~\cite[378]{Steel61}.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure} 

UNCOL:ksi on ehdotettu useita eri välikieliä, mutta yhdestäkään ei ole tullut
niin käytettyä, että sitä voitaisiin sanoa universaaliksi. Eräs UNCOL:ksi ehdotettu
kieli oli Melvin Conwayn 1958 julkaisema välikieli. Conwayn julkaisussa "Proposal for an
UNCOL" määritellään matalan tason välikieli, jota hän kutsuu SML:ksi (Simple Machine Language) ~\cite[5]{Conway58}.
Myöhemmin

Kaikilla laitteilla toimivan välikielen tulisi olla täysin laitteistoriippumaton. 
Laitteistoriippumattomalla kielellä tarkoitetaan, että se voidaan kääntää tehokkaasti
mille tahansa laitteistolle ~\cite[1060]{Brown72}. Koska erilaisia laitteistoja
on hyvin suuri määrä, ei mikään kieli ole täysin laitteistoriippumaton (ibid).
Näin ollen kaikille laitteistoille käännettävän välikielen toteutus on
melko epärealistista. Useat laitteistot ovat kuitenkin tarpeeksi samankaltaisia,
tehokkaan välikielen kehittämiseksi, eikä joukosta puutu kovin moni
oikeassa käytössä oleva tietokone (ibid). % very few machines will be lost, kankeesti sanottu!

%tähän väliin että speetjens ehdotti UMCOLia.

Vaikka välikielet ovat usein laitteistoläheisiä ja ne käännetään suoraan jollekkin
konekielelle, voisi välikieli teoriassa olla hyvinkin korkeatasoinen. Jos jollekin
laitteistolle on olemassa hyvä jonkin korkean tason ohjelmointikielen kääntäjä,
voisi välikieli olla myös korkean tason ohjelmointikieli, jonka kohdekielenä
ei olisi mikään konekieli vaan kyseinen toinen korkean tason ohjelmointikieli ~\cite[1060]{Brown72}.
Koska tällainen tekniikka tuottaa käytännössä aina huonotasoista koodia,
käännetään välikielet lähes poikkeuksetta, vaikka olisivatkin korkean tasoisia
ohjelmointikieliä, suoraan konekieliksi (ibid).



%% ...
%% Vaikka mistään ei tullut universaalia, vaikutti idea kuitenkin välikieltenb kehitykseen..
%% tähän ehkä jotain noita vitun erilaisia välikieliä? vai tulisko sitteki kappaleen alkuun?


%% %ei löydy hyvää lähdettä? entä: http://www.pcmag.com/encyclopedia/term/45156/intermediate-language
%% %Välikielillä tarkoitetaan ohjelmointikieliä, joka on kehitetty toimimaan välivaiheena
%% %käännösprosessissa korkean tason ohjelmointikieliltä konekielille. Välikielten avulla

%% -abstract machine modeling ei ihan sama asia koska voi olla korkean tason välikieliä.
%% -voi olla matalan tai korkean tason tai jotain väliltä.
%% -tunnettu pitkän aikaa -54 ainakin.
%% - since introduction of uncol large number of il have been proposed
%% - ovat usein kehitetty for system development eikä cross compiling ne kaikki perustuu abstract machine modeling konseptiin
%% - erilaisia: machine oriented, problem oriented, hierarcicalk, combinational

%Bootstrapping menetelmää käytetään usein myös ristiinkääntämisessä (cross compiling)
%joten kyseinen luku käsittelee osittain myös sitä.
\section{T-kaaviot}

Kääntäjien suunnittelussa ja mallintamisessa on käytetty useita erilaisia kaavioita.
Käytetyin ja tunnetuin lienee Harvey Bratmanin 1961 ehdottama T-kaavio, jonka
hän kehitti UNCOL-kaavion korvaajaksi ~\cite[]{Bratman61}. 

\subsection{Alkuperäinen Bratman-kaavio}
Harvey Bratman esittelemä kaavio kuvaa yksittäistä kääntäjää. 
Siitä käy ilmi kääntäjän ymmärtämä kohde- ja lähdekieli sekä kieli, jolla kääntäjä toimii.
Kaaviota kutsutaan Bratman-kaavioksi tai T-kaavioksi. Jälkimmäinen nimi tulee kaavion
muodosta, jossa T-kirjaimen muotoisessa alueessa vasempaan päätyyn merkitään lähdekieli,
oikeaan päätyyn kohdekieli ja alaosaan kieli jolla kääntäjä toimii.

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{basic-T.png}
\caption{T-kaavio, joka kuvaa x86-arkkitehtuurilla toimivaa C-kääntäjää, jonka kohdekieli on x86-konekieli.}
\label{kuvaesimerkki}
\end{center}
\end{figure}

Kaavioita toisiinsa liittämällä voidaan havainnollistaa monimutkaisiakin kääntäjillä
suoritettavia toimintaketjuja. Kuvassa 3 oletetaan että, käytössä on C-kielinen
kääntäjä, joka kääntää Ada-kieltä x86-konekielelle. Lisäksi käytössä on edellisen kuvan esimerkissä
oleva x86-arkkitehtuurilla toimiva C-kääntäjä, jonka kohdekieli on x86-konekieli.
Näiden kahden kääntäjän avulla voidaan tuottaa x86-alustalla suoritettava Ada kääntäjä,
jonka kohdekieli on x86. Kahden ensimmäisen kääntäjän yhteistyöllä saadaan siis kolmas
kääntäjä. Huomattavaa on, että kaavion alin kääntäjä toimii aina jossakin todellisessa laitteistossa, eikä täten voi olla muu kuin jonkin laitteiston ymmärtämä konekieli.

%Tähän väliin jää vittumaisesti tyhjää tilaa

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=0.5]{multi-T.png}
\caption{C-kielisen Ada-kääntäjän ja x86:lla toimivan C kääntäjän avulla voidaan tuottaa x86:lla toimiva ada-kääntäjä}
\label{kuvaesimerkki}
\end{center}
\end{figure}

\subsection{Earleyn ja Sturginsin merkintätapa}
T-kaavio on melko yksinkertainen, joten siitä on kehitetty paranneltuja vaihtoehtoja.
Jay Earley ja Howard Sturgis laajensivat Bratmanin kaaviota lisäämällä siihen ominaisuuksia ~\cite[607-616]{Earley70}.
Alkuperäisen T-kaavion kuvatessa vain kääntäjiä, Earleyn ja Sturgisin kaavioissa pystyi
kuvaamaan myös tulkkeja. Lisäksi kaavioon sisällytettiin suoritusta kuvaava osa
sekä sovellusohjelmaa kuvaava kaavio. Heidän kaavioissaan määritellään kuvan 4
mukaiset elementit.

\begin{figure}[H]
\ \newline
\begin{center}
\includegraphics[scale=1.0]{notations-T.png}
\caption{Earleyn ja Sturgisin T-kaavioelementit. Kuvan lähde ~\cite[282]{Mogensen10}.}
\label{kuvaesimerkki}
\end{center}
\end{figure}
Kuvan vasemman puoleisin elementti vastaa Earleyn ja Sturgisin merkintätavassa alkuperäistä T-kaaviota.
Se kuvaa C-kielistä kääntäjää joka kääntää kieleltä A kielelle B. Suorakaiteen muotoinen
kahdesta osasta koostuva kaavio kuvaa tulkkia, joka tulkkaa kieltä C ja toimii kielellä D.
Jotta käännös voitaisiin suorittaa, tulee pohjimmaisen kielen olla suoritettavissa jollakin oikealla
laitteistolla. Tätä suoritusta kuvaamaan lisättiin yksiosainen kolmiomerkintä. Kolmion sisällä
lukee mitä konekieltä suoritus ymmärtää. Esimerkkikuvassa konekieli on D.
Lampun muotoinen kaavio tarkoittaa jotain sovellusohjelmaa tai määrittelemätöntä laskentaa.
Kaavion sisällä lukee ohjelmointikieli, jolla sovellus on ohjelmoitu tai jolle se on käännetty.
Esimerkkikuvassa kieli on D ~\cite[282]{Mogensen10}.

Kyseisiä kaavioita voi yhdistellä hyvinkin monimutkaisiksi rakenteiksi. Kuvan 5 esimerkissä on
kaavio, joka kuvaa C++-kielisen ohjelman kääntämistä x86-konekielelle. Suoritus tapahtuu
x86-laitteistolla ja käännöksen tekee pythonilla toimiva kääntäjä, joka tulkataan x86-laitteistossa.
Huomioitava T-kaavioiden käytössä on, että kaavioiden vierekkäisten osien kielten tulee täsmätä
toisiinsa. Kuvan esimerkin käännös ei voi ottaa lähdeohjelmakseen muuta kuin C++:llä kirjoitetun ohjelman.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{example-Earley-T.png}
		\caption{Esimerkki Earleyn ja Sturgisin kaavioiden yhdistelemisestä.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}


%Tähän lukuun tulee osittain myös cross compiling juttuja. Cross compilingissä kerrotaan enemmän IL pohjaisesti
\section{Kääntäjien rakenne ja ketjutus}
%tähän mennessä lähteinä lähinnä Mogensen ja Appel
Koska kääntäjien ohjelmointi matalan tason ohjelmointikielillä on erittäin vaivalloista ~\cite[281]{Mogensen10},
suositaan niiden kehittämisessä korkean tason ohjelmointikielten käyttöä.
Yksi vaihtoehto on ohjelmoida laitteistolle kääntäjä jollakin kyseiselle laitteistolle
jo olemassa olevalla ohjelmointikielellä. Tämä ei kuitenkaan aina ole mahdollista.
Esimerkiksi, jos kyseessä on uusi prosessoriarkkitehtuuri, eikä tälle vielä ole kääntäjiä,
on ohjelmointi tehtävä jollakin muulla tavalla.
Kääntäjän joka sekä kääntää että on suoritettavissa kyseisellä laitteistolla tuottamiseksi, eräs
yleisesti käytetty menetelmä on ketjutus (bootstrapping) ~\cite[281]{Mogensen10}. %IBID!

Ketjutus on tekniikka, jonka ydinajatus on kääntää jokin kääntäjä sillä itsellään ~\cite[281]{Mogensen10}
ja tavanomaisen kääntäjän sanotaan olevan ketjutettu jos se kääntää itsensä ~\cite[]{Appel94}.

\subsection{Iteratiivinen ketjutus}
%incremental bootstrap
%aloita kuvaamalla tilanne jossa ei ole kääntäjiä?
Perinteinen ongelma kääntäjien kehityksessä on tilanne, jossa kääntäjä pitää ohjelmoida
ilman muita työkaluja ja käänäjiä. Iteratiivisessa ketjutus-
menetelmässä kääntäjä kehitetään kahdessa osassa. Ensin kääntäjästä tehdään
hyvin suppea versio, joka osaa kääntää tavoitellusta ohjelmointikielestä vain pienen
osajoukon ~\cite[287]{Mogensen10}. Tämä ensimmäisen vaiheen kääntäjä voidaan ohjelmoida
millä tahansa ohjelmointikielellä, mutta mikäli muiden ohjelmointikielten kääntäjiä
ei ole saatavilla, se joudutaan tekemään konekielellä. Toisessa osassa kääntäjä
ohjelmoidaan sen itsensä ymmärtämällä kielellä, eikä muita ohjelmointikieliä enää tarvita.
Tällöin jo olemassa oleva kääntäjä voi kääntää seuraavan version itsestään. 
Koska kieli on tässä vaiheessa vielä hyvin vajavainen, olisi valmiin ohjelmointikielen
toteuttaminen heti ensimmäisen vaiheen jälkeen erittäin työlästä tai mahdotonta. Toista vaihetta %olisko mahdotonta?
suoritetaan useita kertoja siten, että kääntäjän tuntemaa ohjelmointikieltä kasvatetaan
ja siitä käännetään uusi kääntäjä, jonka avulla kieltä taas kasvatetaan, ja niin edelleen.
Huomioitavaa prosessissa on se, että kääntäjän uusi versio on kehitettävä aina käyttäen 
vanhan version tuntemaa ohjelmointikieltä. 

Kuva 5 esittää edellä mainittua tilannetta. Ensimmäisessä vaiheessa kääntäjän ensimmäinen
versio ohjelmoidaan konekielellä (ML, "Machine Language") ja tämän jälkeen ohjelmointikieltä (PL, "Programming Language") laajennetaan iteratiivisesti, kunnes tavoiteltu kieli on saavutettu.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{iterative-bootstrap-from-scratch.png}
		\caption{Iteratiivinen bootsträppäys ilman muita ohjelmointikieliä.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

Eräs ongelma edellä kuvatussa prosessissa on kielen kehitykseen soveltuvan
sopivan osajoukon löytäminen ~\cite[176]{Reynolds03}. Mikäli ohjelmointikieltä laajennetaan vain
vähän, on päivitys lähes hyödytön. Liian monimutkaisen kielen toteuttaminen
yksinkertaisella osajoukolla on puolestaan erittäin työlästä.

\subsection{Ketjutus olemassa olevien kääntäjien avulla}
%half bootstrap TÄMÄ KOKO KAPPALE ON VÄHÄN HEIKOSTI KIRJOITETTU.
Ketjutus-menetelmää käytetään usein myös yhdessä ristiinkääntämisen (cross compiling) kanssa ~\cite[175]{Reynolds03}.
Tällöin tavoitteena on siirtää jo olemassa oleva kääntäjä toimimaan toisessa laitteistossa.
Oletetaan, että laitteistolle, joka suorittaa konekieltä ML1 on toteutettu kielen PL kääntäjä.
Haluttaessa kielen PL kääntäjä toimimaan sekä tuottamaan uuden laitteiston konekieltä ML2, 
voidaan kielen PL kääntäjä ohjelmoida uudelle laitteistolle ristiinkääntämistä ja ketjuttamista käyttäen
seuraavalla tavalla. Ensin kielellä PL ohjelmoidaan sen itsensä kääntäjä uudelle laitteistolle.
Tämä voidaan kääntää alkuperäisellä laitteistolla. Nyt kielelle PL on olemassa uudelle laitteistolle
koodia tuottava kääntäjä, mutta sen suoritus tapahtuu edelleen vanhassa laitteistossa (ristiin kääntäminen).
Nyt Kääntäjän uudella versiolla, jonka kohdekieli on ML2, käännettäessä oma lähdekoodinsa,
saadaan kääntäjä, joka sekä toimii että kääntää kielelle ML2.
Kuva 6 havainnollistaa tilannetta. Ensimmäisessä vaiheessa jo olemassa olevalla kääntäjällä
käännetään uuden kääntäjän lähdekoodi, jolloin tulokseksi saadaan ristiinkääntäjä.
Saadulla uudella kääntäjällä käännetään sen oma lähdekoodi, jolloin tuloksena on haluttu
uudella laitteistolla toimiva ja sen konekieltä tuottava PL kielen kääntäjä.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{cross-bootstrap-T.png}
		\caption{Kääntäjän siirtäminen uudelle laitteistolle ristiinkääntämisen ja ketjutuksen avulla.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

%esimerkikksi ibm -> control data cite reynolds
%tässä vois jo mainita intermediate languagen ja puhua front ja backendeistä

%ir bootstrap
Edellämainittu esimerkki on toimiva, mutta se edellyttää kääntäjän kirjoittamisen kokonaan
alusta loppuun asti sen omalla lähdekielellä. Koska korkean tason ohjelmointikielten
kääntäjät voivat olla todella monimutkaisia ja koostua suuresta määrästä lähdekoodia,
on tämänkaltainen prosessi varsin työläs. Vastaavan prosessin voi toteuttaa huomattavasti
pienemmällä vaivalla, mikäli alkuperäisen kääntäjän rakenne olisi eri tavalla toteutettu.

%ibid
\subsection{Ketjuttamista helpottava kääntäjärakenne}
Vielä 1970-luvulla kääntäjät kirjoitettiin hyvin tarkasti tiettyä lähdekieltä ja laitteistoa varten ~\cite[38]{Guilan02}.
1980-luvulla ruvettiin kehittämään enenevässä määrin kääntäjäkokonaisuuksia, jotka kykenevät 
kääntämään useita eri lähdekieliä (ibid). Tällaisissa systeemeissä kääntäjän sisäinen rakenne oli 
jaettu lähdekielestä riippuvaiseen etuosaan (frontend) sekä näiden jakamaan takaosaan (backend).
Tämän kaltainen rakenne vähensi tarvetta kirjoittaa uutta koodia ja näin ollen pienensi kääntäjien kehityksestä
koituvia kustannuksia. 80-luvun lopulla oli jo hyväksytty ajatus siitä, että kääntäjien
kehitys usealle ohjelmointikielelle ja/tai laitteistolle  on tehokkaampaa sekä kilpailukykyisempää (ibid).

%tää nyt ei ihan oo usealle eri kielelle mutta ehkä usealle eri laitteistolle
Eräs tyypillinen tapa kääntäjien ohjelmoinnissa onkin jakaa sen sisäistä rakennetta sekä
suorittaa käännös useassa eri vaiheessa. Apuna käytetään usein jotakin niinsanottua 
välikieltä (intermediate language) ~\cite[15]{Speetjens76}. Näin haluttu lähdekieli voidaan kääntää
helpommin eri laitteistoille.

%tää ois sit usealle eri laitteistolle.
Oletettaen, että jollekin välikielelle IL (Intermediate Language) ja jollekin korkean tason ohjelmointikielelle on
olemassa tietyllä laitteistolla toimivat kääntäjät,
voidaan halutun lähdekielen käännös suorittaa kaksivaiheisesti toteuttamalla
korkean tason ohjelmointikielellä kääntäjä lähdekieleltä välikielelle ~\cite[610]{Earley70}.
Uuden lähdekielen toteutus sisältää siis vain korkean tason ohjelmointikielellä tehdyn
kääntäjän käytetylle välikielelle, eikä koodin generointivaihetta tarvitse kirjoittaa uudestaan.

%antaako tää kappalevaihdos nyt ymmärtää että kuva 7 olisi ylemmän tilanteen kaltainen?
Kuva 7 demonstroi usein käytettyä rakennetta ~\cite[610]{Earley70}, jolla kääntäjän jatkokehitystä voidaan
helpottaa huomattavasti. 

Uuden ohjelmointikielen kääntäjän toteuttaminen kyseisen kääntäjän avulla on mahdollista
vain yhden komponentin (punainen) uudelleenohjelmoinnilla. Vaihtamalla toisen vaiheen 
ensimmäinen kääntäjä kääntämään uudelta lähdekieleltä (SL, "Source Language") välikielelle,
vaihtuu myös seuraavissa komponenteissa olevat lähdekielet uuteen kieleen.
Uusi kääntäjä tulee toteuttaa samalla, ohjelmointikielellä, jolla aiempi komponentti oli
toteutettu (CWL, "Compiler Writing Language). Esimerkiksi haluttaessa kyseisellä järjestelmällä
toteuttaa konekielellä ML1 suoritettava C-kääntäjä, tulee ohjelmoida vain sellainen
osa, joka on kirjoitettu kielellä CWL ja kääntää C-kieltä välikielellä IL. Sama pätee
muihinkin toteutettaviin ohjelmointikieliin.

\begin{figure}[H]
	\ \newline
	\begin{center}
%          \hspace{-55pt} 55 liikaa 50 ei ollenk
	    \hbox{\hspace{-0.6cm} \includegraphics[scale=1.0]{compiler-complex-color-T.png}}
	  \caption{Kääntäjäkokonaisuus.}
	  \label{kuvaesimerkki}
	\end{center}
\end{figure}

Pelkkää välikieltä apuna käyttäen uuden ohjelmointikielen toteutus ei vaatisi näin
monimutkaista rakennetta. Kyseinen rakenne mahdollistaa kuitenkin sekä tehokkaan ristiinkääntämisen,
että itsensä ketjuttamisen uudelle laitteistolle. Jos kääntäjäkokonaisuuden halutaan
kääntävän ymmärtämäänsä lähdekieltä uudelle laitteistolle, jonka konekieli on ML2, joudutaan siihen
edelleen kirjoittamaan vain yksi uusi komponentti. Tämä osa kirjoitetaan kielellä CWL ja
se kääntää välikieltä IL uuden laitteiston ymmärtämälle konekielelle ML2.  Kun kyseinen
osa käännetään jo olemassa olevalla kääntäjällä, saadaan tulokseksi
samassa laitteistossa toimiva kääntäjä välikieleltä uudelle konekielelle.
Saadulla ristiinkääntäjällä on siis mahdollista kääntää lähdekieltä
konekielelle ML2, mutta sen suoritus tapahtuu edelleen kielen alkuperäistä
konekieltä ML1 ymmärtävässä laitteistossa.

Ristiinkääntämisen mahdollistavan uuden osan avulla myös koko kääntäjärakenteen
ketjuttamisen uuteen laitteistoon on mahdollista ilman lisäohjelmointia ~\cite[610]{Earley70}.
Kuva 8 havainnollistaa tätä prosessia.
Ensimmäisessä vaiheessa jo olemassaolevien
komponenttien sekä uuden CWL:llä kirjoitetun välikielikääntäjän (keltainen) avulla
tuotetaan seuraavissa vaiheissa tarvittavat komponentit.

Näiden komponenttien avulla voidaan
toisessa vaiheessa tuottaa ML2-konekielellä toimiva ja siihen kääntävä välikielikääntäjä.
Kolmannessa vaiheessa tuotetaan ensimmäisessä vaiheessa saadun välikielikääntäjän
avulla ML2-kielellä toimiva CWL-kääntäjä, joka tuottaa välikieltä.

\begin{figure}[H]
	\ \newline
	\begin{center}
		\includegraphics[scale=1.0]{CWL-IL-bootstrap-complex-color-T.png}
		\caption{Käänätäkokonaisuuden ketjutus uudelle laitteistolle.}
		\label{kuvaesimerkki}
	\end{center}
\end{figure}

Toisessa ja kolmannessa vaiheessa saadut kääntäjät (sininen) sijoittamalla alkuperäiseen %ei ihan! pitää vielä saada CWL,ML2,ML2
ohjelmistoon, saadaan sekä ML2-kielellä toimivat, että sille kääntävät
komponentit. Ainoa komponentti jota ei saada suoraan sijoittamalla on ensimmäisen vaiheen toinen komponentti.
Uudella konekielellä toimivat kääntäjät CWL -> IL ja IL -> ML2 
vastaavat kuitenkin tätä komponenttia.

Käsitelty kääntäjäkokonaisuus on monimutkainen, mutta myös tehokas. Sekä uuden
lähdekielen toteutus alkuperäisellä laitteistolla, että koko kääntäjäohjelmiston
siirtäminen uuteen laitteistoon voidaan saavuttaa
vain pienen osan uudelleenohjelmoinnilla. Lisäksi uudelleenohjelmointi
voidaan suorittaa jo aiemmin käytetyllä korkean tason ohjelmointikielellä ~\cite[610]{Earley70}.

%jos tää monimutkanen esimerkki tulis cross compiling ja välikielie setin loppuun niin tästä olis
%luontevaa jatkaa puhumaan front ja backendistä ja vaikka gcc rakenteesta. 

%half bootstrap



\section{Yhteenveto}

Tietojenkäsittelytieteessä kääntäjä tarkoittaa ohjelmaa joka kääntää lähdekielisen
ohjelmakoodin kohdekieliseksi ohjelmakoodiksi. Koska ennen muun kuin konekielten
kehitystä ohjelmointi tapahtui suoraan laitearkkitehtuurin ymmärtämällä muodolla,
ei tarvetta kääntäjille ollut. Koska konekoodin ohjelmointi oli varsin työlästä,
kehitettiin avuksi symbolisia konekieliä, joissa tietyt binäärijonot oli korvattu
paremmin muistettavilla tekstuaalisilla symboleilla.

Korkeamman tason ohjelmointikielet kehittyivät ohjelmoijien tarpeesta kuvata
ohjelmistojen toimintaa korkeammilla abstraktiotasoilla. Täsmälliset
kuvausjärjestelmät kehitettiin alunperin ilman ajatusta kääntäjistä taikka
automaattisesta koodin generoinnista. Vaikka kuvausjärjestelmien sekä koodia
generoivien algoritmien kehitys oli alkuun vain teoreettista tutkimista,
huomattiin potentiaali niiden tehokkaaseen käyttöön varsin pian. Tämän jälkeen
ohjelmointikieliä ruvettiin kehittämään varta vasten automaattisen koodin
generoinnin takia ja ensimmäiset oikeasti hyödylliset kielet sekä niiden
kääntäjät kehitettiin. 


\newpage
%
% Sitten alkaa lähdeluettelo
%


%ONKO LÄHDELUETTELO OK? MIKSI [1] jne?
\nocite{*}
 \bibliographystyle{apalike}
\bibliography{lahteet}

\lastpage

%\appendices

%\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

%Liitteet ovat tässä vain sisällysluettelon ja esitystavan mallina.
%Jokainen liite aloitetaan yleensä uudelta sivulta, jonka alkuun tulee
%liitteen numero ja nimi. Kunkin liitteen sivut numeroidaan erikseen.

%Liite on paitsi dokumenttia täydentävä osuus myös itsenäinen
%kokonaisuus. Liite ei siten voi olla pelkästään kuva tai ohjelmanpätkä,
%vaan liitteessä on ilmaistava sen sisällön laatu ja tarkoitus.


\end{document}
